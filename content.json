{"meta":{"title":"笑笑前端圈","subtitle":null,"description":null,"author":"Xiaoxiao","url":"http://xiaoxiaoqdq.com"},"pages":[{"title":"About us","date":"2017-03-10T05:26:24.000Z","updated":"2017-03-11T15:51:56.000Z","comments":true,"path":"about/index.html","permalink":"http://xiaoxiaoqdq.com/about/index.html","excerpt":"","text":"笑笑前端圈是一群志同道合而又富有激情的前端爱好者（也就是笑笑团队）创建的纯净，高质量的前端交流学习平台。 既然选择了远方，便只顾风雨兼程！"}],"posts":[{"title":"WebAssembly 系列（一）生动形象地介绍 WebAssembly","slug":"js-WebAssembly-1","date":"2017-03-16T10:11:00.000Z","updated":"2017-03-16T10:13:29.265Z","comments":true,"path":"/blog/js-WebAssembly-1/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-WebAssembly-1/","excerpt":"","text":"你可能已经听说过，WebAssembly 执行的更快。但是 WebAssembly 为什么执行的更快呢？ 在这个系列文章中，我会为你解释这一点。 等等，什么是 WebAssembly？WebAssembly 是除了 JavaScript 以外，另一种可以在浏览器中执行的编程语言。所以当人们说 WebAssembly 更快的时候，一般来讲是与 JavaScript 相比而言的。 我不会暗示大家开发时对二者的选择——或者选择 WebAssembly，或者选择 JavaScript。实际上，我们更希望在同一个工程中，两个你同时使用。 对二者的比较倒是非常有必要的，这样你就可以了解到 WebAssembly 所拥有的独特特性。 一些关于性能的历史JavaScript 于 1995 年问世，它的设计初衷并不是为了执行起来快，在前 10 个年头，它的执行速度也确实不快。 紧接着，浏览器市场竞争开始激烈起来。 被人们广为传播的“性能大战”在 2008 年打响。许多浏览器引入了 Just-in-time 编译器，也叫 JIT。基于 JIT 的模式，JavaScript 代码的运行渐渐变快。 正是由于这些 JIT 的引入，使得 JavaScript 的性能达到了一个转折点，JS 代码执行速度快了 10 倍。 随着性能的提升，JavaScript 可以应用到以前根本没有想到过的领域，比如用于后端开发的 Node.js。性能的提升使得 JavaScript 的应用范围得到很大的扩展。 现在通过 WebAssembly，我们很有可能正处于第二个拐点。 所以，接下来，我们深入了解一下为什么 WebAssembly 更快、执行效率更高。 接下来一系列的文章希望读者能够细细品味，仔细阅读，文章如下： 背景知识： JavaScript Just-in-time (JIT) 工作原理 编译器如何生成汇编 当前 WebAssembly 的状况 WebAssembly 工作原理 为什么 WebAssembly 更快？ WebAssembly 的未来 WebAssembly 的现在与未来 本文作者：Lin Clark英文原文：A cartoon intro to WebAssembly","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://xiaoxiaoqdq.com/tags/WebAssembly/"}]},{"title":"WebAssembly 系列（六）WebAssembly 的现在与未来","slug":"js-WebAssembly-6","date":"2017-03-16T10:08:00.000Z","updated":"2017-03-16T10:11:13.450Z","comments":true,"path":"/blog/js-WebAssembly-6/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-WebAssembly-6/","excerpt":"","text":"本文是关于 WebAssembly 系列的第六篇文章（本系列共六篇文章，后续会将连接补充归整），也同时是本系列的收尾文章。如果你没有读先前文章的话，建议先读这里（英文文章）。如果对 WebAssembly 没概念，建议先读这里（中文文章）。* 2017 年 2 月 28 日，四个主要的浏览器一致同意宣布 WebAssembly 的MVP 版本已经完成，它是一个浏览器可以搭载的稳定版本。 它提供了浏览器可以搭载的稳定核，这个核并没有包含 WebAssembly 组织所计划的所有特征，而是提供了可以使 WebAssembly 稳定运行的基本版本。 这样一来开发者就可以使用 WebAssembly 代码了。对于旧版本的浏览器，开发者可以通过 asm.js 来向下兼容代码，asm.js 是 JavaScript 的一个子集，所有 JS 引擎都可以使用它。另外，通过 Emscripten 工具，你可以把你的应用编译成 WebAssembly 或者 asm.js。 尽管是第一个版本，WebAssembly 已经能发挥出它的优势了，未来通过不断地改善和融入新特征，WebAssembly 会变的更快。 提升浏览器中 WebAssembly 的性能随着各种浏览器都使自己的引擎支持 WebAssembly，速度提升就变成自然而然的了，目前各大浏览器厂商都在积极推动这件事情。 JavaScript 和 WebAssembly 之间调用的中间函数目前，在 JS 中调用 WebAssembly 的速度比本应达到的速度要慢。这是因为中间需要做一次“蹦床运动”。JIT 没有办法直接处理 WebAssembly，所以 JIT 要先把 WebAssembly 函数发送到懂它的地方。这一过程是引擎中比较慢的地方。 按理来讲，如果 JIT 知道如何直接处理 WebAssembly 函数，那么速度会有百倍的提升。 如果你传递的是单一任务给 WebAssembly 模块，那么不用担心这个开销，因为只有一次转换，也会比较快。但是如果是频繁地从 WebAssembly 和 JavaScript 之间切换，那么这个开销就必须要考虑了。 快速加载JIT 必须要在快速加载和快速执行之间做权衡。如果在编译和优化阶段花了大量的时间，那么执行的必然会很快，但是启动会比较慢。目前有大量的工作正在研究，如何使预编译时间和程序真正执行时间两者平衡。 WebAssembly 不需要对变量类型做优化假设，所以引擎也不关心在运行时的变量类型。这就给效率的提升提供了更多的可能性，比如可以使编译和执行这两个过程并行。 加之最新增加的 JavaScript API 允许 WebAssembly 的流编译，这就使得在字节流还在下载的时候就启动编译。 FireFox 目前正在开发两个编译器系统。一个编译器先启动，对代码进行部分优化。在代码已经开始运行时，第二个编译器会在后台对代码进行全优化，当全优化过程完毕，就会将代码替换成全优化版本继续执行。 添加后续特性到 WebAssembly 标准的过程WebAssembly 的发展是采用小步迭代的方式，边测试边开发，而不是预先设计好一切。 这就意味着有很多功能还在襁褓之中，没有经过彻底思考以及实际验证。它们想要写进标准，还要通过所有的浏览器厂商的积极参与。 这些特性叫做：未来特性。这里列出几个。 直接操作 DOM目前 WebAssembly 没有任何方法可以与 DOM 直接交互。就是说你还不能通过比如 element.innerHTML 的方法来更新节点。 想要操作 DOM，必须要通过 JS。那么你就要在 WebAssembly 中调用 JavaScript 函数（WebAssembly 模块中，既可以引入 WebAssembly 函数，也可以引入 JavaScript 函数）。 不管怎么样，都要通过 JS 来实现，这比直接访问 DOM 要慢得多，所以这是未来一定要解决的一个问题。 共享内存的并发性提升代码执行速度的一个方法是使代码并行运行，不过有时也会适得其反，因为不同的线程在同步的时候可能会花费更多的时间。 这时如果能够使不同的线程共享内存，那就能降低这种开销。实现这一功能 WebAssembly 将会使用 JavaScript 中的 SharedArrayBuffer，而这一功能的实现将会提高程序执行的效率。 SIMD（单指令，多数据）如果你之前了解过 WebAssembly 相关的内容，你可能会听说过 SIMD，全称是：Single Instruction, Multiple Data（单指令，多数据），这是并行化的另一种方法。 SIMD 在处理存放大量数据的数据结构有其独特的优势。比如存放了很多不同数据的 vector（容器），就可以用同一个指令同时对容器的不同部分做处理。这种方法会大幅提高复杂计算的效率，比如游戏或者 VR。 这对于普通 web 应用开发者不是很重要，但是对于多媒体、游戏开发者非常关键。 异常处理许多语言都仿照 C++ 式的异常处理，但是 WebAssembly 并没有包含异常处理。 如果你用 Emscripten 编译代码，就知道它会模拟异常处理，但是这一过程非常之慢，慢到你都想用 “DISABLE_EXCEPTION_CATCHING” 标记把异常处理关掉。 如果异常处理加入到了 WebAssembly，那就不用采用模拟的方式了。而异常处理对于开发者来讲又特别重要，所以这也是未来的一大功能点。 其他改进——使开发者开发起来更简单一些未来特性不是针对性能的，而是使开发者开发 WebAssembly 更方便。 一流的开发者工具。目前在浏览器中调试 WebAssembly 就像调试汇编一样，很少的开发者可以手动地把自己的源代码和汇编代码对应起来。我们在致力于开发出更加适合开发者调试源代码的工具。 垃圾回收。如果你能提前确定变量类型，那就可以把你的代码变成 WebAssembly，例如 TypeScript 代码就可以编译成 WebAssembly。但是现在的问题是 WebAssembly 没办法处理垃圾回收的问题，WebAssembly 中的内存操作都是手动的。所以 WebAssembly 会考虑提供方便的 GC 功能，以方便开发者使用。 ES6 模块集成。目前浏览器在逐渐支持用 script 标记来加载 JavaScript 模块。一旦这一功能被完美执行，那么像 &lt;script src=url type=&quot;module&quot;&gt; 这样的标记就可以运行了，这里的 url 可以换成 WebAssembly 模块。 总结WebAssembly 执行起来更快，随着浏览器逐步支持了 WebAssembly 的各种特性，WebAssembly 将会变得更快。 本文作者：Lin Clark英文原文：Where is WebAssembly now and what’s next?","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://xiaoxiaoqdq.com/tags/WebAssembly/"}]},{"title":"WebAssembly 系列（五）为什么 WebAssembly 更快？","slug":"js-WebAssembly-5","date":"2017-03-15T10:18:00.000Z","updated":"2017-03-16T10:08:16.662Z","comments":true,"path":"/blog/js-WebAssembly-5/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-WebAssembly-5/","excerpt":"","text":"本文是关于 WebAssembly 系列的第五篇文章（本系列共六篇文章，后续会将连接补充归整）。 上一篇文章中，我介绍了如何编写 WebAssembly 程序，也表达了我希望看到更多的开发者在自己的工程中同时使用 WebAssembly 和 JavaScript 的期许。 开发者们不必纠结于到底选择 WebAssembly 还是 JavaScript，已经有了 JavaScript 工程的开发者们，希望能把部分 JavaScript 替换成 WebAssembly 来尝试使用。 例如，正在开发 React 程序的团队可以把协调性代码（即虚拟 DOM）替换成 WebAssembly 的版本。而对于你的 web 应用的用户来说，他们就跟以前一样使用，不会发生任何变化，同时他们还能享受到 WebAssembly 所带来的好处——快。 而开发者们选择替换为 WebAssembly 的原因正是因为 WebAssembly 比较快。 当前的 JavaScript 性能如何？在我们了解 JavaScript 和 WebAssembly 的性能区别之前，需要先理解 JS 引擎的工作原理。 下面这张图片介绍了性能使用的大概分布情况。 JS 引擎在图中各个部分所花的时间取决于页面所用的 JavaScript 代码。图表中的比例并不代表真实情况下的确切比例情况。 图中的每一个颜色条都代表了不同的任务： Parsing——表示把源代码变成解释器可以运行的代码所花的时间； Compiling + optimizing——表示基线编译器和优化编译器花的时间。一些优化编译器的工作并不在主线程运行，不包含在这里。 Re-optimizing——当 JIT 发现优化假设错误，丢弃优化代码所花的时间。包括重优化的时间、抛弃并返回到基线编译器的时间。 Execution——执行代码的时间 Garbage collection——垃圾回收，清理内存的时间 这里注意：这些任务并不是离散执行的，或者按固定顺序依次执行的。而是交叉执行，比如正在进行解析过程时，其他一些代码正在运行，而另一些正在编译。 这样的交叉执行给早期 JavaScript 带来了很大的效率提升，早期的 JavaScript 执行类似于下图，各个过程顺序进行： 早期时，JavaScript 只有解释器，执行起来非常慢。当引入了 JIT 后，大大提升了执行效率，缩短了执行时间。 JIT 所付出的开销是对代码的监视和编译时间。JavaScript 开发者可以像以前那样开发 JavaScript 程序，而同样的程序，解析和编译的时间也大大缩短。这就使得开发者们更加倾向于开发更复杂的 JavaScript 应用。 同时，这也说明了执行效率上还有很大的提升空间。 WebAssembly 对比下面是 WebAssembly 和典型的 web 应用的近似对比图： 各种浏览器处理上图中不同的过程，有着细微的差别，拿 SpiderMonkey 作为例子。 文件获取这一步并没有显示在图表中，但是这看似简单地从服务器获取文件这个步骤，却会花费很长时间。 WebAssembly 比 JavaScript 的压缩率更高，所以文件获取也更快。即便通过压缩算法可以显著地减小 JavaScript 的包大小，但是压缩后的 WebAssembly 的二进制代码依然更小。 这就是说在服务器和客户端之间传输文件更快，尤其在网络不好的情况下。 解析当到达浏览器时，JavaScript 源代码就被解析成了抽象语法树。 浏览器采用懒加载的方式进行，只解析真正需要的部分，而对于浏览器暂时不需要的函数只保留它的桩（stub，译者注：关于桩的解释可以在之前的文章中有提及）。 解析过后 AST （抽象语法树）就变成了中间代码（叫做字节码），提供给 JS 引擎编译。 而 WebAssembly 则不需要这种转换，因为它本身就是中间代码。它要做的只是解码并且检查确认代码没有错误就可以了。 编译和优化在关于 JIT 的文章中，我有介绍过，JavaScript 是在代码的执行阶段编译的。因为它是弱类型语言，当变量类型发生变化时，同样的代码会被编译成不同版本。 不同浏览器处理 WebAssembly 的编译过程也不同，有些浏览器只对 WebAssembly 做基线编译，而另一些浏览器用 JIT 来编译。 不论哪种方式，WebAssembly 都更贴近机器码，所以它更快，使它更快的原因有几个： 在编译优化代码之前，它不需要提前运行代码以知道变量都是什么类型。 编译器不需要对同样的代码做不同版本的编译。 很多优化在 LLVM 阶段就已经做完了，所以在编译和优化的时候没有太多的优化需要做。 重优化有些情况下，JIT 会反复地进行“抛弃优化代码&lt;-&gt;重优化”过程。 当 JIT 在优化假设阶段做的假设，执行阶段发现是不正确的时候，就会发生这种情况。比如当循环中发现本次循环所使用的变量类型和上次循环的类型不一样，或者原型链中插入了新的函数，都会使 JIT 抛弃已优化的代码。 反优化过程有两部分开销。第一，需要花时间丢掉已优化的代码并且回到基线版本。第二，如果函数依旧频繁被调用，JIT 可能会再次把它发送到优化编译器，又做一次优化编译，这是在做无用功。 在 WebAssembly 中，类型都是确定了的，所以 JIT 不需要根据变量的类型做优化假设。也就是说 WebAssembly 没有重优化阶段。 执行自己也可以写出执行效率很高的 JavaScript 代码。你需要了解 JIT 的优化机制，例如你要知道什么样的代码编译器会对其进行特殊处理（JIT 文章里面有提到过）。 然而大多数的开发者是不知道 JIT 内部的实现机制的。即使开发者知道 JIT 的内部机制，也很难写出符合 JIT 标准的代码，因为人们通常为了代码可读性更好而使用的编码模式，恰恰不合适编译器对代码的优化。 加之 JIT 会针对不同的浏览器做不同的优化，所以对于一个浏览器优化的比较好，很可能在另外一个浏览器上执行效率就比较差。 正是因为这样，执行 WebAssembly 通常会比较快，很多 JIT 为 JavaScript 所做的优化在 WebAssembly 并不需要。另外，WebAssembly 就是为了编译器而设计的，开发人员不直接对其进行编程，这样就使得 WebAssembly 专注于提供更加理想的指令（执行效率更高的指令）给机器就好了。 执行效率方面，不同的代码功能有不同的效果，一般来讲执行效率会提高 10% - 800%。 垃圾回收JavaScript 中，开发者不需要手动清理内存中不用的变量。JS 引擎会自动地做这件事情，这个过程叫做垃圾回收。 可是，当你想要实现性能可控，垃圾回收可能就是个问题了。垃圾回收器会自动开始，这是不受你控制的，所以很有可能它会在一个不合适的时机启动。目前的大多数浏览器已经能给垃圾回收安排一个合理的启动时间，不过这还是会增加代码执行的开销。 目前为止，WebAssembly 不支持垃圾回收。内存操作都是手动控制的（像 C、C++一样）。这对于开发者来讲确实增加了些开发成本，不过这也使代码的执行效率更高。 总结WebAssembly 比 JavaScript 执行更快是因为： 文件抓取阶段，WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段，WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段，WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段，WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&lt;-&gt;重优化”现象。 执行阶段，WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段，WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。 这就是为什么在大多数情况下，同一个任务 WebAssembly 比 JavaScript 表现更好的原因。 但是，还有一些情况 WebAssembly 表现的会不如预期；同时 WebAssembly 的未来也会朝着使 WebAssembly 执行效率更高的方向发展。这些我会在下一篇文章《WebAssembly 的现在与未来》中介绍。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://xiaoxiaoqdq.com/tags/WebAssembly/"}]},{"title":"WebAssembly 系列（四）WebAssembly 工作原理","slug":"js-WebAssembly-4","date":"2017-03-14T15:18:00.000Z","updated":"2017-03-16T10:08:03.128Z","comments":true,"path":"/blog/js-WebAssembly-4/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-WebAssembly-4/","excerpt":"","text":"WebAssembly 是除了 JavaScript 以外，另一种可以在网页中运行的编程语言。过去如果你想在浏览器中运行代码来对网页中各种元素进行控制，只有 JavaScript 这一种选择。 所以当人们谈论 WebAssembly 的时候，往往会拿 JavaScript 来进行比较。但是它们其实并不是“二选一”的关系——并不是只能用 WebAssembly 或者 JavaScript。 实际上，我们鼓励开发者将这两种语言一起使用，即使你不亲自实现 WebAssembly 模块，你也可以学习它现有的模块，并它的优势来实现你的功能。 WebAssembly 模块定义的一些功能可以通过 JavaScript 来调用。所以就像你通过 npm 下载 lodash 模块并通过 API 使用它一样，未来你也可以下载 WebAssembly 模块并且使用其提供的功能。 那么就让我们来看一下如何开发 WebAssembly 模块，以及如何通过 JavaScript 使用他们。 WebAssembly 处于哪个环节？在上一篇关于汇编的文章中，我介绍了编译器是如何从高级语言翻译到机器码的。 那么在上图中，WebAssembly 在什么位置呢？实际上，你可以把它看成另一种“目标汇编语言”。 每一种目标汇编语言（x86、ARM）都依赖于特定的机器结构。当你想要把你的代码放到用户的机器上执行的时候，你并不知道目标机器结构是什么样的。 而 WebAssembly 与其他的汇编语言不一样，它不依赖于具体的物理机器。可以抽象地理解成它是概念机器的机器语言，而不是实际的物理机器的机器语言。 正因为如此，WebAssembly 指令有时也被称为虚拟指令。它比 JavaScript 代码更直接地映射到机器码，它也代表了“如何能在通用的硬件上更有效地执行代码”的一种理念。所以它并不直接映射成特定硬件的机器码。 浏览器把 WebAssembly 下载下来后，可以迅速地将其转换成机器汇编代码。 编译到 .wasm 文件目前对于 WebAssembly 支持情况最好的编译器工具链是 LLVM。有很多不同的前端和后端插件可以用在 LLVM 上。 提示：很多 WebAssembly 开发者用 C 语言或者 Rust 开发，再编译成 WebAssembly。其实还有其他的方式来开发 WebAssembly 模块。例如利用 TypeScript 开发 WebAssembly 模块，或者直接用文本格式的 WebAssembly 也可以。 假设想从 C 语言到 WebAssembly，我们就需要 clang 前端来把 C 代码变成 LLVM 中间代码。当变换成了 LLVM IR 时，说明 LLVM 已经理解了代码，它会对代码自动地做一些优化。 为了从 LLVM IR 生成 WebAssembly，还需要后端编译器。在 LLVM 的工程中有正在开发中的后端，而且应该很快就开发完成了，现在这个时间节点，暂时还看不到它是如何起作用的。 还有一个易用的工具，叫做 Emscripten。它通过自己的后端先把代码转换成自己的中间代码（叫做 asm.js），然后再转化成 WebAssembly。实际上它背后也是使用的 LLVM。 Emscripten 还包含了许多额外的工具和库来包容整个 C/C++ 代码库，所以它更像是一个软件开发者工具包（SDK）而不是编译器。例如系统开发者需要文件系统以对文件进行读写，Emscripten 就有一个 IndexedDB 来模拟文件系统。 不考虑太多的这些工具链，只要知道最终生成了 .wasm 文件就可以了。后面我会介绍 .wasm 文件的结构，在这之前先一起了解一下在 JS 中如何使用它。 加载一个 .wasm 模块到 JavaScript.wasm 文件是 WebAssembly 模块，它可以加载到 JavaScript 中使用，现阶段加载的过程稍微有点复杂。 12345678function fetchAndInstantiate(url, importObject) &#123; return fetch(url).then(response =&gt; response.arrayBuffer() ).then(bytes =&gt; WebAssembly.instantiate(bytes, importObject) ).then(results =&gt; results.instance );&#125; 如果想深入了解，可以在 MDN 文档中了解更多。 我们一直在致力于把这一过程变得简单，对工具链进行优化。希望能够把它整合到现有的模块打包工具中，比如 webpack 中，或者整合到加载器中，比如 SystemJS 中。我们相信加载 WebAssembly 模块也可以像加载 JavaScript 一样简单。 这里介绍 WebAssembly 模块和 JavaScript 模块的主要区别。当前的 WebAssembly 只能使用数字（整型或者浮点型）作为参数或者返回值。 对于任何其他的复杂类型，比如 string，就必须得用 WebAssembly 模块的内存操作了。如果是经常使用 JavaScript，对直接操作内存不是很熟悉的话，可以回想一下 C、C++ 和 Rust 这些语言，它们都是手动操作内存。WebAssembly 的内存操作和这些语言的内存操作很像。 为了实现这个功能，它使用了 JavaScript 中称为 ArrayBuffer 的数据结构。ArrayBuffer 是一个字节数组，所以它的索引（index）就相当于内存地址了。 如果你想在 JavaScript 和 WebAssembly 之间传递字符串，可以利用 ArrayBuffer 将其写入内存中，这时候 ArrayBuffer 的索引就是整型了，可以把它传递给 WebAssembly 函数。此时，第一个字符的索引就可以当做指针来使用。 这就好像一个 web 开发者在开发 WebAssembly 模块时，把这个模块包装了一层外衣。这样其他使用者在使用这个模块的时候，就不用关心内存管理的细节。 如果你想了解更多的内存管理，看一下我们写的 WebAssembly 的内存操作。 .wasm 文件结构如果你是写高级语言的开发者，并且通过编译器编译成 WebAssembly，那你不用关心 WebAssembly 模块的结构。但是了解它的结构有助于你理解一些基本问题。 如果你对编译器还不了解，建议先读一下“系列三之编译器如何生成汇编这篇文章。 这段代码是即将生成 WebAssembly 的 C 代码： 12int add42(int num) &#123; return num + 42;&#125; 你可以使用 WASM Explorer 来编译这个函数。 打开 .wasm 文件（假设你的编辑器支持的话），可以看到下面代码： 123456700 61 73 6D 0D 00 00 00 01 86 80 80 80 00 01 6001 7F 01 7F 03 82 80 80 80 00 01 00 04 84 80 8080 00 01 70 00 00 05 83 80 80 80 00 01 00 01 0681 80 80 80 00 00 07 96 80 80 80 00 02 06 6D 656D 6F 72 79 02 00 09 5F 5A 35 61 64 64 34 32 6900 00 0A 8D 80 80 80 00 01 87 80 80 80 00 00 2000 41 2A 6A 0B 这是模块的“二进制”表示。之所以用引号把“二进制”引起来，是因为上面其实是用十六进制表示的，不过把它变成二进制或者人们能看懂的十进制表示也很容易。 例如，下面是 num + 42 的各种表示方法。 代码是如何工作的：基于栈的虚拟机如果你对具体的操作过程很好奇，那么这幅图可以告诉你指令都做了什么。 从图中我们可以注意到 加 操作并没有指定哪两个数字进行加。这是因为 WebAssembly 是采用“基于栈的虚拟机”的机制。即一个操作符所需要的所有值，在操作进行之前都已经存放在堆栈中。 所有的操作符，比如加法，都知道自己需要多少个值。加需要两个值，所以它从堆栈顶部取两个值就可以了。那么加指令就可以变的更短（单字节），因为指令不需要指定源寄存器和目的寄存器。这也使得 .wasm 文件变得更小，进而使得加载 .wasm 文件更快。 尽管 WebAssembly 使用基于栈的虚拟机，但是并不是说在实际的物理机器上它就是这么生效的。当浏览器翻译 WebAssembly 到机器码时，浏览器会使用寄存器，而 WebAssembly 代码并不指定用哪些寄存器，这样做的好处是给浏览器最大的自由度，让其自己来进行寄存器的最佳分配。 WebAssembly 模块的组成部分除了上面介绍的，.wasm 文件还有其他部分。一些组成部分对于模块来讲是必须的，一些是可选的。 必须部分： Type。在模块中定义的函数的函数声明和所有引入函数的函数声明。 Function。给出模块中每个函数一个索引。 Code。模块中每个函数的实际函数体。 可选部分： Export。使函数、内存、表（tables）、全局变量等对其他 WebAssembly 或 JavaScript 可见，允许动态链接一些分开编译的组件，即 .dll 的WebAssembly 版本。 Import。允许从其他 WebAssembly 或者 JavaScript 中导入指定的函数、内存、表或者全局变量。 Start。当 WebAssembly 模块加载进来的时候，可以自动运行的函数（类似于 main 函数）。 Global。声明模块的全局变量。 Memory。定义模块用到的内存。 Table。使得可以映射到 WebAssembly 模块以外的值，如映射到 JavaScript 的对象。这在间接函数调用时很有用。 Data。初始化导入的或者局部内存。 Element。初始化导入的或者局部的表。 如果你想了解关于这些组成部分的更深入的内容，可以阅读这些组成部分的工作原理。 下文预告现在你已经了解了 WebAssembly 的工作原理，下面将会介绍为什么 WebAssembly 运行的更快。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://xiaoxiaoqdq.com/tags/WebAssembly/"}]},{"title":"WebAssembly 系列（三）汇编速成课","slug":"js-WebAssembly-3","date":"2017-03-14T15:11:00.000Z","updated":"2017-03-16T10:07:49.619Z","comments":true,"path":"/blog/js-WebAssembly-3/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-WebAssembly-3/","excerpt":"","text":"本文是关于 WebAssembly 系列的第三篇文章。建议先阅读公众号中以前发出的文章哦。 理解什么是汇编，以及编译器如何生成它，对于理解 WebAssembly 是很有帮助的。 在上一篇关于 JIT 的文章中，我介绍了和计算机打交道，就像同外星人打交道一样。 现在来思考一下“外星人”的大脑是如何工作的——机器的“大脑”是如何对我们输入给它的内容进行分析和理解的。 “大脑”中，有一部分负责思考——处理加法、减法或者逻辑运算。还有其他的部分分别负责短暂记忆和长期记忆的。 这些不同的部分都有自己的名字： 负责思考的部分叫做算数逻辑单元（ALU） 寄存器提供短暂记忆功能 随机存取存储器（RAM）提供长期记忆功能 机器代码中的语句称作指令。 那么在指令进入“大脑”以后都发生了什么呢？它们会被切分为不同的部分传送到不同的单元进行处理。 “大脑”切分指令通过不同连接线路进行。举个例子，“大脑”会将指令最开始的 6 比特通过管道送到 ALU 中。而 ALU 会通过 0 和 1 的位置来决定对两个数做加法。 这串 01 串就叫做“操作码”，它告诉了 ALU 要执行什么样的操作。 然后“大脑”会取后面两个连续的 3 比特 01 串来确定把哪两个数加到一起，而这 3 比特指的是寄存器的地址。 注意看上面机器码的注释：“ADD R1 R2”，这对于人类来讲很容易理解其含义。这就是汇编，也叫符号机器码，它使人类也能看懂机器代码的含义。 可以看到汇编和这台机器的机器码之间有直接的映射关系。正是因为如此，拥有不同机器结构的计算机会有不同的汇编系统。如果你有一个机器，它有自己的内部结构，那么它就需要它所独有的汇编语言。 从上面的分析可以知道我们进行机器码的翻译并不是只有一种，不同的机器有不同的机器码，就像我们人类也说各种各样的语言一样，机器也“说”不同的语言。 人类和外星人之间的语言翻译，可能会从英语、德语或中文翻译到外星语 A 或者外星语 B。而在程序的世界里，则是从 C、C++ 或者 JAVA 翻译到 x86 或者 ARM。 你想要从任意一个高级语言翻译到众多汇编语言中的一种（依赖机器内部结构），其中一种方式是创建不同的翻译器来完成各种高级语言到汇编的映射。 这种翻译的效率实在太低了。为了解决这个问题，大多数编译器都会在中间多加一层。它会把高级语言翻译到一个低层，而这个低层又没有低到机器码这个层级。这就是中间代码（ intermediate representation，IR）。 这就是说编译器会把高级语言翻译到 IR 语言，而编译器另外的部分再把 IR 语言编译成特定目标结构的可执行代码。 重新总结一下：编译器的前端把高级语言翻译到 IR，编译器的后端把 IR 翻译成目标机器的汇编代码。 总结本文介绍了什么是汇编以及编译器是如何把高级语言翻译成汇编语言的，在下一篇文章中，我们来介绍 WebAssembly 的工作原理。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://xiaoxiaoqdq.com/tags/WebAssembly/"}]},{"title":"WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理","slug":"js-just-in-time","date":"2017-03-14T14:49:00.000Z","updated":"2017-03-16T10:07:41.010Z","comments":true,"path":"/blog/js-just-in-time/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-just-in-time/","excerpt":"","text":"本文是关于 WebAssembly 系列的第二篇文章。如果你没有读先前文章的话，建议先读这里（英文文章）。如果对 WebAssembly 没概念，建议先读这里（中文文章）。 JavaScript 的启动比较缓慢，但是通过 JIT 可以使其变快，那么 JIT 是如何起作用的呢？ JavaScript 在浏览器中是如何运行的？如果是你一个开发者，当你决定在你的页面中使用 JavaScript 的时候，有两个要考虑的事情：目标和问题。 目标：告诉计算机你想做什么。 问题：你和计算机说不同的语言，无法沟通。 你说的是人类的语言，而计算机用的是机器语言。机器语言也是一种语言，只是 JavaScript 或者其他高级编程语言机器能看得懂，而人类不用他们来交流罢了。它们是基于人类认知而设计出来的。 所以呢，JavaScript 引擎的工作就是把人类的语言转换成机器能看懂的语言。 这就像电影《降临》中，人类和外星人的互相交流一样。 在电影里面，人类和外星人不仅仅是语言不同，两个群体看待世界的方式都是不一样的。其实人类和机器也是类似（后面我会详细介绍）。 那么翻译是如何进行的呢？ 在代码的世界中，通常有两种方式来翻译机器语言：解释器和编译器。 如果是通过解释器，翻译是一行行地边解释边执行 编译器是把源代码整个编译成目标代码，执行时不再需要编译器，直接在支持目标代码的平台上运行。 这两种翻译的方式都各有利弊。 解释器的利弊解释器启动和执行的更快。你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。 正是因为这个原因，解释器看起来更加适合 JavaScript。对于一个 Web 开发人员来讲，能够快速执行代码并看到结果是非常重要的。 这就是为什么最开始的浏览器都是用 JavaScript 解释器的原因。 可是当你运行同样的代码一次以上的时候，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现。 编译器的利弊编译器的问题则恰好相反。 它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。 另外一个不同是，编译器可以用更多的时间对代码进行优化，以使的代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化。 Just-in-time 编译器：综合了两者的优点为了解决解释器的低效问题，后来的浏览器把编译器也引入进来，形成混合模式。 不同的浏览器实现这一功能的方式不同，不过其基本思想是一致的。在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。 起初，监视器监视着所有通过解释器的代码。 如果同一行代码运行了几次，这个代码段就被标记成了 “warm”，如果运行了很多次，则被标记成 “hot”。 基线编译器如果一段代码变成了 “warm”，那么 JIT 就把它送到编译器去编译，并且把编译结果存储起来。 代码段的每一行都会被编译成一个“桩”（stub），同时给这个桩分配一个以“行号 + 变量类型”的索引。如果监视器监视到了执行同样的代码和同样的变量类型，那么就直接把这个已编译的版本 push 出来给浏览器。 通过这样的做法可以加快执行速度，但是正如前面我所说的，编译器还可以找到更有效地执行代码的方法，也就是做优化。 基线编译器可以做一部分这样的优化（下面我会给出例子），不过基线编译器优化的时间不能太久，因为会使得程序的执行在这里 hold 住。 不过如果代码确实非常 “hot”（也就是说几乎所有的执行时间都耗费在这里），那么花点时间做优化也是值得的。 优化编译器如果一个代码段变得 “very hot”，监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储之。 为了生成一个更快速的代码版本，优化编译器必须做一些假设。例如，它会假设由同一个构造函数生成的实例都有相同的形状——就是说所有的实例都有相同的属性名，并且都以同样的顺序初始化，那么就可以针对这一模式进行优化。 整个优化器起作用的链条是这样的，监视器从他所监视代码的执行情况做出自己的判断，接下来把它所整理的信息传递给优化器进行优化。如果某个循环中先前每次迭代的对象都有相同的形状，那么就可以认为它以后迭代的对象的形状都是相同的。可是对于 JavaScript 从来就没有保证这么一说，前 99 个对象保持着形状，可能第 100 个就少了某个属性。 正是由于这样的情况，所以编译代码需要在运行之前检查其假设是不是合理的。如果合理，那么优化的编译代码会运行，如果不合理，那么 JIT 会认为做了一个错误的假设，并且把优化代码丢掉。 这时（发生优化代码丢弃的情况）执行过程将会回到解释器或者基线编译器，这一过程叫做去优化。 通常优化编译器会使得代码变得更快，但是一些情况也会引起一些意想不到的性能问题。如果你的代码一直陷入优化&lt;-&gt;去优化的怪圈，那么程序执行将会变慢，还不如基线编译器快。 大多数的浏览器都做了限制，当优化/去优化循环发生的时候会尝试跳出这种循环。比如，如果 JIT 做了 10 次以上的优化并且又丢弃的操作，那么就不继续尝试去优化这段代码了桩。 一个优化的例子：类型特化（Type specialization）有很多不同类型的优化方法，这里我介绍一种，让大家能够明白是如何优化的。优化编译器最成功一个特点叫做类型特化，下面详细解释。 JavaScript 所使用的动态类型体系在运行时需要进行额外的解释工作，例如下面代码： 123456function arraySum(arr) &#123; var sum = 0; for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125;&#125; += 循环中这一步看起来很简单，只需要进行一步计算，但是恰恰因为是用动态类型，他所需要的步骤要比你所想象的更复杂一些。 我们假设 arr 是一个有 100 个整数的数组。当代码被标记为 “warm” 时，基线编译器就为函数中的每一个操作生成一个桩。sum += arr[i]会有一个相应的桩，并且把里面的 += 操作当成整数加法。 但是，sum 和 arr[i] 两个数并不保证都是整数。因为在 JavaScript 中类型都是动态类型，在接下来的循环当中，arr[i] 很有可能变成了string 类型。整数加法和字符串连接是完全不同的两个操作，会被编译成不同的机器码。 JIT 处理这个问题的方法是编译多基线桩。如果一个代码段是单一形态的（即总是以同一类型被调用），则只生成一个桩。如果是多形态的（即调用的过程中，类型不断变化），则会为操作所调用的每一个类型组合生成一个桩。 这就是说 JIT 在选择一个桩之前，会进行多分枝选择，类似于决策树，问自己很多问题才会确定最终选择哪个，见下图： 正是因为在基线编译器中每行代码都有自己的桩，所以 JIT 在每行代码被执行的时候都会检查数据类型。在循环的每次迭代，JIT 也都会重复一次分枝选择。 如果代码在执行的过程中，JIT 不是每次都重复检查的话，那么执行的还会更快一些，而这就是优化编译器所需要做的工作之一了。 优化编译器中，整个函数被统一编译，这样的话就可以在循环开始执行之前进行类型检查。 一些浏览器的 JIT 优化更加复杂。比如在 Firefox 中，给一些数组设定了特定的类型，比如里面只包含整型。如果 arr 是这种数组类型，那么 JIT 就不需要检查 arr[i] 是不是整型了，这也意味着 JIT 可以在进入循环之前进行所有的类型检查。 总结简而言之 JIT 是什么呢？它是使 JavaScript 运行更快的一种手段，通过监视代码的运行状态，把 hot 代码（重复执行多次的代码）进行优化。通过这种方式，可以使 JavaScript 应用的性能提升很多倍。 为了使执行速度变快，JIT 会增加很多多余的开销，这些开销包括： 优化和去优化开销 监视器记录信息对内存的开销 发生去优化情况时恢复信息的记录对内存的开销 对基线版本和优化后版本记录的内存开销 这里还有很大的提升空间：即消除开销。通过消除开销使得性能上有进一步地提升，这也是 WebAssembly 所要做的事之一。 英文原文：https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://xiaoxiaoqdq.com/tags/WebAssembly/"}]},{"title":"前端开发中像素的概念 ","slug":"web-pixels","date":"2017-03-13T13:59:00.000Z","updated":"2017-03-14T15:36:16.000Z","comments":true,"path":"/blog/web-pixels/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/web-pixels/","excerpt":"","text":"何为像素我们看到所显示在屏幕上的图像,实际上都是由非常多的像素点所组成。各个像素点通过发出不同颜色的光来呈现屏幕的色彩。 下面介绍一些和像素相关的概念 设备像素(物理像素)它是物理上的概念，随着设备生产出来就已经被确定了。例如iPhone5的分辨率是640x1136px,代表屏幕由640行,1136列像素点组成。 小知识:屏幕普遍采用RGB色域(红、绿、蓝三个子像素构成),而印刷行业普遍使用CMYK色域(青、品红、黄和黑) CSS像素CSS像素是web编程的概念,是相对的而不是绝对的单位，因为平常电脑屏幕1px对应了1px物理像素，所以感觉不到两者的区别，会让你误以为CSS里的1px就是实际屏幕像素 事实上只有zoom 100%的情况下,1个CSS像素才会等于1个设备像素 设备像素（深蓝色背景）和CSS像素（半透明前景） 当用户进行缩小操作的时候:可以看到,一个设备像素覆盖了多个CSS像素 当用户进行放大操作的时候:可以看到一个CSS像素覆盖了多个设备像素 小结:用户的缩放比会影响单位CSS像素点对应的实际物理像素的多少,看到这里，你就应该知道，CSS像素只是一个相对单位，与物理像素并不总是等价的 此像素非彼像素正如这篇文章的前端工程师需要明白的「像素」开头中的场景，这简直是跟我刚开始实习的时候场景一模一样。 阿树：哇靠，为啥你给的设计稿是640px宽 ，iPhone 5不是320px宽吗？？？ 玉凤：A pixel is not a pixel is not a pixel, you know ? 事实上，他们都是对的，只是谈到的不是同一个“像素”。在上一章节中我们介绍了,CSS像素并不总等于物理像素。 我们知道,iPhone 3GS的屏幕和iPhone 4/4s都是3.5英寸的。过去iPhone 3GS的时候,和平时电脑屏幕一样,在缩放比为100%的情况下,1px CSS像素对应着1px物理像素。开发者在开发网页的时候只需要写上CSS像素width:320px,height:480px。但是面对同样屏幕尺寸的iPhone4/4s,分辨率提升到了640x960，整整比3GS的分辨率大了一倍。在相同的屏幕尺寸下塞入更多的像素点，这需要引入另一个重要的概念： 像素密度(PPI,Pixels Per Inch) 像素密度，准确的说是每平方英寸的面积上排列的像素点数量。1英寸是一个固定长度，等于2.54厘米。像素密度越高，代表屏幕显示效果越精细。 #看到这里可能你会困惑，如果像素密度提高了一倍的话，那么原本显示正常的网页岂不是变得非常的小？ 比如在分辨率为320x480的iPhone 3GS上，要画一条1英寸的线条，假设需要163像素,即CSS像素设成 163 像素即可；但是在分辨率为 640×960 的 iPhone4/4s 上，163 个 CSS 像素所在手机表示实际长度只有 iPhone3GS 的一半，即 0.5 英寸。如果照这种方式显示，3GS 上刚刚好的效果，在 4/4s 上就会小到根本看不清了。 但是在现实中并没有发生这种情况,因为: 也就是说,为了避免因为分辨率成倍提高造成的问题(高分辨率屏看网页看不清楚),Retina屏幕将2x2的像素当做1个像素来使用。阅览网页的时候，iPhone 4/4S与3GS是一样的显示，但是画质却更加细腻了。 逻辑像素(dp,pt)为了抹去高密度分辨率屏幕(高清屏)所带来的适配问题,iOS与Android两个平台分别提出了pt（point）与dp(device-independent pixel)两个单位。他们的名称不一样，但是内涵是一样的。下面我们以iPhone为例 例如将4/4s的逻辑像素设定为320x480pt（实际像素:640x960px）,以物理屏幕左上角为原点,横向X轴320pt,纵向Y轴480pt。所以PPI越高，1pt的所覆盖的物理像素就越多。 设备像素比（DPR，Device Pixel Ratio） 之前我们已经介绍了物理像素与逻辑像素的概念,就可以很容易推导出设备像素比的公式了12345DRP = 物理像素/dp或pt1倍：1pt=1dp=1px（iPhone 3GS）2倍：1pt=1dp=2px（iPhone 4s/5/6）3倍：1pt=1dp=3px（iPhone 6 plus） 总结1个CSS像素相当于多少个物理像素,取决于: 页面缩放比 屏幕密度 所以设计师给的是640px宽的设计稿是根据设备像素(device pixel,物理像素)为单位制作的设计稿;而前端工程师参照相关的设备像素比来进行换算 比如根据iPhone5出稿的设计稿的中有一个width:100px,height:200px的按钮那么前端工程师在编码web页面时应该写width:50px,height:100px. 他们之间的换算比例是根据设备像素比来计算的","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"WEB","slug":"前端笔记/WEB","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/WEB/"}],"tags":[{"name":"概念","slug":"概念","permalink":"http://xiaoxiaoqdq.com/tags/概念/"}]},{"title":"详解 CSS 居中布局技巧","slug":"cs-layout-center","date":"2017-03-12T10:20:00.000Z","updated":"2017-03-14T14:47:52.000Z","comments":true,"path":"/blog/cs-layout-center/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/cs-layout-center/","excerpt":"","text":"水平居中元素： 通用方法，元素的宽高未知方式一：CSS3 transform 12345678.parent&#123; position:absolute;&#125;.child&#123; position:absolute; left:50%; transform:translate(-50%);&#125; 方式二：Flex 布局 1234.parent&#123; display:flex; justify-content:center;&#125; 适用于子元素为浮动，绝对定位，内联元素，均可水平居中。 居中的元素为常规文档流中的内联元素(display: inline) 常见的内联元素有：span, a, img, input, label 等等 123.parent&#123; text-align: center;&#125; 此方法同样适用于 display: inline-block 的元素。 居中的元素为常规文档流中的块元素(display: block) 常见的块元素：div, h1~h6, table, p, ul, li 等等 方式一：设置 margin 123456789.parent&#123; width:100%;&#125;.child&#123; width:600px; height:50px; margin:0 auto; background:#999;&#125; 此方法只能进行水平的居中，且对浮动元素或绝对定位元素无效。 方式二：修改为 inline-block 属性 123456.parent&#123; text-align:center;&#125;.child&#123; display:inline-block;&#125; 居中的元素为浮动元素 1234567.child&#123; width:100px; float:left; position:relative; left:50%; margin-left:-50px;&#125; 居中的元素为绝对定位元素 方式一： 123456789.parent&#123; position:relative;&#125;.child&#123; position:absolute; width:100px; left:50%; margin-left:-50px;&#125; 方式二： 12345678910.parent&#123; position:relative;&#125;.child&#123; position:absolute; width:100px; left:0; right:0; margin:0 auto;&#125; 垂直居中元素： 通用方法，元素的宽高未知 方式一：CSS3 transform 12345678.parent&#123; position:relative;&#125;.child&#123; position:absolute; top:50%; transform:translateY(-50%);&#125; 方式二：Flex 布局 1234.parent&#123; display:flex; align-item:center;&#125; 适用于子元素为浮动，绝对定位，内联元素，均可垂直居中。 居中元素为单行文本 1234.text&#123; line-height: 200px; height:200px;&#125; 把文字的 line-height 设为文字父容器的高度，适用于只有一行文字的情况。 已知元素宽高 方式一： 123456789.parent&#123; position:relative;&#125;.child&#123; position:absolute; top:50%; height:100px; margin-top:-50px;&#125; 方式二： 12345678910.parent&#123; position:relative;&#125;.child&#123; position:absolute; top:0; bottom:0; height:100px; margin-top:auto 0;&#125; 垂直居中元素： 1.绝对居中定位 12345678910div&#123; width:100px; height:100px; margin:auto; position: fixed; //absolute is ok top:0; right:0; bottom:0; left:0;&#125; 优点： 不仅可以实现在正中间，还可以在正左方，正右方 元素的宽高支持百分比 % 属性值和 min-/max- 属性 可以封装为一个公共类，可做弹出层 浏览器支持性好 2.负边距居中 123456789div&#123; width:100px; height:100px; position:absolute; top:50%; right:50%; margin-left:-50px; margin-top:-50px;&#125; 特点： 良好的跨浏览器特性,兼容 IE6 - IE7 灵活性差，不能自适应，宽高不支持百分比尺寸和 min-/max- 属性 3.Transform 定位 12345678div&#123; width:100px; height:100px; position:absolute; top:50%; right:50%; transform:translate(-50%,-50%);&#125; 特点： 内容可自适应，可以封装为一个公共类，可做弹出层 可能干扰其他 transform 效果 4.Flexbox 布局 12345.parent&#123; display:flex; justify-content:center; align-item:center;&#125; 这是 CSS 布局未来的趋势。Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。 5.table-cell 居中 1234567891011121314.parent&#123; display:table-cell; vertical-align: middle; text-align:center; width:200px; height:200px; border:1px solid red;&#125;.child&#123; width:100px; height: 100px; display: inline-block; background-color:#03f;&#125; 适用于子元素 display 为 inline-block, inline 类型的元素，需要已知父元素的宽高，且父元素的宽高不能设为百分比数。 6.font-size 配合 vertical-align 实现垂直居中 12345678910111213.parent&#123; font-size:175.4px; height:200px; text-align:center;&#125;.child&#123; vertical-align:middle; display:inline-block; font-size:12px; width: 50px; height: 50px; background-color:#00f;&#125; 该方法的要点是给父元素设一个合适的 font-size 的值，这个值的取值为该父元素的高度除以 1.14 得到的值，并且子元素必须 是一个 inline 或 inline-block 元素，需要加上 vertical-align: middle 属性。使用这种方法，子元素的宽度或高度都不必知道。 具体原理可以上网搜 vertical-align 垂直居中。 7.文本内容居中 12345text&#123; height:100px; line-height:100px; text-align:center;&#125;","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"CSS","slug":"前端笔记/CSS","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://xiaoxiaoqdq.com/tags/css/"}]},{"title":"掌握 HTTP 缓存——从请求到响应过程的一切","slug":"se-http-cdn","date":"2017-03-11T15:32:00.000Z","updated":"2017-03-12T05:52:02.000Z","comments":true,"path":"/blog/se-http-cdn/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/se-http-cdn/","excerpt":"","text":"CDN类的网站曾经一度雄踞 Alexa 域名排行的前 100。以前一些小网站不需要使用 CDN 或者根本负担不起其价格，不过这一现象近几年发生了很大的变化，CDN 市场上出现了很多按次付费，非公司性的提供商，这使得 CDN 变成人人都能负担的起的一种服务了。本文讲述的就是如何使用这种简单易用的缓存服务。 使用内容分发网络（ CDN ）你需要先正确地认识 HTTP 响应头：和 HTTP 响应头中的哪些标签相关？它们是怎么起作用的？如何使用它们？文章中我会回答这些问题。 本文讲的并不会像教科书那么精确，实际上在某些情况下，为了叙述的清晰、简洁，我会按自己的理解简化某些问题，文章中会通过一些实际的例子来介绍缓存理论。在这篇文章的基础上，还会写一些文章来介绍对于某些指定的 CMS 或框架如何使用 CDN 来作为缓存层。 为什么使用 CDN？CDN 是一个全球分布式网络，它把网站内容更快地传递给全球范围内的一个具体位置，而往往这个具体的位置离实际的内容服务器距离很远。举个例子，你的网站主机在爱尔兰，而你的用户则在澳大利亚访问。这时当你的用户访问你的网站的时候，延迟会很大，把你的（静态）数据用 CDN 放到澳大利亚则会很大程度上提高用户访问网站的体验。 然而 CDN 的使用并不局限于此。其实 CDN 可以理解成一个普通缓存，如代理缓存（边缘缓存）。即便你并不关心用户的具体地理位置，你也应该考虑使用 CDN 的代理缓存来提高你的用户体验。 为什么使用代理缓存？简而言之，代理缓存会缓存你网站一些页面，通过缓存来传输“静态”内容非常快。一个简单的例子，假设你有一个带有开始页面的博客，这里面列出了所有近期的博客列表。完成这一过程，PHP 脚本要从数据库中获取到最近的文章实体，并且将它们转换成 HTML 结果页并返回给用户。因此，对于一次请求（访问）包含了：一次 PHP 执行 + 一组数据库查询。对于 1000 次请求（访问）包含了：1000 次 PHP 执行 + 1000 组数据库查询。每一次 PHP 执行都要进行 CPU、内存和 I/O 操作，对于数据库操作也是同样。 请求的需求量和访问用户的多少呈线性正比关系。听起来怎么样？不怎么样，因为这个线性关系是有最大限度的：磁盘最大只能提供一定程度的 I/O，CPU 和内存也都不是无限的。这样下去到了某个点，也就是说某个资源到了瓶颈的时候，就出现问题了：你的网站会访问的非常慢，甚至会出现所有人都不能访问的情况。其实这时其他资源并没有被全部打满。诚然，这时你可以扩展你的硬件规模来突破这一瓶颈，但是这将使工程变得很复杂，成本也更高。实际上还有更简单、更便宜的解决方法。 在中间加一层代理缓存，会减少资源对你的限制。拿前面的例子来讲，使用代理缓存只有第一次请求需要执行 PHP 脚本、查询数据库和生成 HTML 结果页。所有后面过来的请求都会从这个缓存中取内容，读取缓存几乎和直接读取内存一样快。这意味着，上面的线性规模瓶颈的问题解决了！100 个用户或者1000 个用户都没关系，依然只有 1 次 PHP 执行、1 次数据库查询和 1 次的结果页生成。 CDN != CDNCDN 的类型也各有不同。网站管理者可能会好奇数据是怎么存储的？存放在哪？以及数据是如何分布在 CDN 上的？是如何分发的呢？本文不是写给网站管理者的而是写给开发者的，所以在这我只能告诉你有“经典 CDN”和“对等 CDN”，后者是现在主流采用的方法。 对于开发者，相比于把数据拿到 CDN 以后做什么来说，会对如何把数据放到 CDN 中更感兴趣。说起来，有 push CDN 和 pull CDN 两种。顾名思义，“push CDN” 表示你要给 CDN 提供内容；“pull CDN” 表示如何从 CDN 取内容。 本文将主要介绍 pull CDN，因为在很多情况下 pull CDN 更加简单易用，不需要费多大事就能集成到现有的网站中。 pull CDN 是如何起作用的？我们来做个例子，假设你有一个可访问的网站，URL 是 https://www.foobar.tld。在这样的场景下，域名 www.foobar.tld 会被放到 pull CDN 服务器中，而不是你的网站服务器中。CDN 作为你网站服务器的一个代理。 还有一个不被公开的域名指向实际的网站服务器。在这个例子中假设它是 direct.foobar.tld，实际网站服务器叫做源。 这个 CDN 将会接受所有的请求。如果它的缓存中有结果的话将会直接返回给用户，否则会将这个请求托管给你实际的网站服务器，然后把返回的结果缓存起来为以后的请求做储备，同时将结果返回给用户。 最简单的 pull CDN 运行的过程如下： 获取一个页面的请求，这个页面：http://www.foobar.tld/some/page 把 some/page 当做缓存 key 检查缓存中是否存在 在缓存中则直接从缓存中返回结果给用户 不在缓存则请求 http://direct.foobar.tld/some/page，把返回的结果以 some/page 作为 key 写入缓存，并返回结果给用户 静态内容 VS 动态内容上面的这一过程对于完全静态的内容完全适用。静态内容指的是如果用户访问同一个 URL 地址，返回的所有数据都是一样的。比如 CSS 文件就有这样的特点，http://www.foobar.tld/public/css/main.css 这个文件是一个普通文件，对于所有访问网站的用户都是一样的，那么它就特别适合用缓存存起来。 和静态文件相对的是动态文件。内容在运行时才能确定，这种情况也是非常常见的。比如多语言问题，需要根据浏览器语言来返回内容。还有一些和 “user session” 相关的内容，比如当用户登陆了以后，就要把“登陆”按钮换成“退出”按钮，你肯定不希望这个被缓存。这些高度活跃的内容（如每小时或者更短时间更新的页面）不能被缓存，或者说不能在缓存中停留时间过长。 这就是缓存有意思的地方，理解和实现它并不难。 缓存头绝大多数的 pull CDN 采用以“每页”缓存形式解决动态内容的问题。为了达到这样的效果，一个简单的方法是 HTPP 响应缓存头。 首先对于缓存头你需要知道有“旧版本”和“新版本”两种，就是说它并不是一开始就设计成当前所使用的这个版本的，也有一个逐渐演变的过程。新版本指的是 HTTP/1.1，而旧版本指的是 HTTP/1.0。它有特别多的可选选项，每个人对这个问题都很头疼。我认为这是大家不愿意使用缓存头的最重要的原因。 言归正传，我们只关注 ETag 和 Cache-Control 这两个标签就足以了。大多数 CDN 还支持旧版本（Expires，Pragma 和 Age），不过这些只作为向后兼容来使用。 ETag 头我们从最简单的开始 ETag：它是文档版本的标识符。通常是内容的 MD5 值，不过它也可以包含其他内容，代表的是文档的版本/日期，如： 1.0 或者 2017-02-27。这里注意一点是，它必须用双引号括起来，如：ETag: &quot;d3b07384d113edec49eaa6238ad5ff00&quot;。 二次验证现在来考虑 ETag 的实际应用：二次验证。我们暂时不考虑前面代理+源的架构模式，只考虑简单的客户端-服务器模式。如下图： 假设客户端请求了 http://www.foobar.tld/hello.txt，接着服务端返回了如下的响应内容：12345678910111213141516 # REQUEST GET /hello.txt HTTP/1.1 Host: www.foobar.tld # RESPONSE HTTP/1.1 200 OK Date: Sun, 05 Feb 2017 12:34:56 UTC Server: Apache Last-Modified: Sun, 05 Feb 2017 10:34:56 UTC ETag: &quot;8a75d48aaf3e72648a4e3747b713d730&quot; Content-Length: 8 Content-Type: text/plain; charset=UTF-8``` `the body`在响应里面，有两个有意思的头标识：一个是 `ETag`，内容的 MD5值，一个是 `Last-Modified`，这是 `hello.txt` 文件最后一次被修改的时间。这里就是二次验证起作用的地方：当客户端在很短的时间内再次访问上面的 URL，客户端浏览器会使用 `If-*` 请求头。如 `If-None-Match` 检查 `ETag` 的内容是否有改变。也就是说，如果 `ETag` 发生变化，客户端接收到的一个完整的新响应；如果 `ETag` 没变化，客户端接收到的是一个表明内容没变化的标识。 GET /hello.txt HTTP/1.1 If-None-Match: &quot;8a75d48aaf3e72648a4e3747b713d730&quot; Host: www.foobar.tld 123456789如果 `ETag` 没有改变，那么服务端将会返回：``` HTTP/1.1 304 Not Modified Date: Sun, 05 Feb 2017 12:34:57 UTC Server: Apache Last-Modified: Sun, 05 Feb 2017 10:34:56 UTC ETag: &quot;8a75d48aaf3e72648a4e3747b713d730&quot; Content-Length: 8 Content-Type: text/plain; charset=UTF-8 正如上面所展示的，这次服务器的响应里面不是 200 ok，而是304 Not Modified，这就是说它略过包体部分，让客户端直接去自己的缓存里拿数据。在这个例子中，包体内容是 the body，比较小，效果不明显。可是想象一下如果是很大的内容呢，或者是很复杂的动态生成内容呢，价值就很大了。 作为一个开发者，你可能会想：“并没有那么好用嘛，我还不得不掌握 IF- 类的头标识，比以前更费事了”。 别急，这只是介绍了共享缓存，也就是代理缓存的由来，我们看原始的架构：&lt;客户端-代理-源端&gt;，代理根据自己的缓存返回给客户端 304 Not Modified，接下来的章节详解介绍，介绍之前我要先讲一下 Last-Modfied 头。 在处理上面那个 hello.txt 静态文件的例子时，客户端还可以使用 If-Not-Modified-Since: Sun, 05 Feb 2017 10:34:56 UTC 来达到同样的效果（返回 304 响应）。这对于静态文件来说也很好用，因为响应头中的 Last-Modified 标识是根据服务器磁盘上的“更改时间戳”自动生成的。然而，“更改时间戳”对于动态文件通常没什么用，因为动态生成文件频繁更新，时间戳很难确定。我们都知道，你最想缓存起来的是内容，生成内容的代价是最大的，所以 ETag 头是更好的选择。 Cache-Control头Cache-Control 头相对来讲难一些。两个原因：第一，Cache-Control 既可以用于请求头，也可以用于响应头。本文中着重讨论响应头，因为这是开发者所必须要掌握的。第二，它控制着两个缓存：本地缓存（又称私有缓存）和共享缓存。 本地缓存，是指在客户端本地机器中的缓存。站在开发者的角度，它并不完全受你的控制，通常浏览器会自己决定是否把某些内容放到缓存中，这意味着：不要依赖于本地缓存。用户也可能在关闭浏览器的时候清理所有缓存，而你并不知道有这样的操作。除非你监测到了某个用户的流量不断上涨，导致缓存内容迅速失效，这时候你才会意识到。 共享缓存，也就是本文所介绍的：处于客户端和服务器之间的缓存。即 CDN。你对共享缓存拥有绝对的控制，应该好好地利用它。 现在我们来用一些代码作为示例深入学习一下。 Cache-Control: public max-age=3600 Cache-Control: private immutable Cache-Control: no-cache Cache-Control: public max-age=3600 s-maxage=7200 Cache-Control: public max-age=3600 proxy-revalidate 乍一看这些代码很令人困惑，但是不要担心，它并没有那么难，我来一点点介绍。首先你要知道 Cache-Control 有三种属性：缓冲能力、过期时间和二次验证。 首先是缓冲能力，它关注的是缓存到什么地方，和是否应该被缓存。他的几个重要的属性是： private：表示它只应该存在本地缓存； public：表示它既可以存在共享缓存，也可以被存在本地缓存； no-cache：表示不论是本地缓存还是共享缓存，在使用它以前必须用缓存里的值来重新验证； no-store：表示不允许被缓存。 第二个是过期时间，很显然它关注的是内容可以被缓存多久。它的几个重要的属性是： max-age=&lt;seconds&gt;：设置缓存时间，设置单位为秒。本地缓存和共享缓存都可以； s-maxage=&lt;seconds&gt;：覆盖 max-age 属性。只在共享缓存中起作用。 最后一个是二次验证，表示精细控制。它的几个重要属性是： immutable：表示文档是不能更改的。 must-revalidate：表示客户端（浏览器）必须检查代理服务器上是否存在，即使它已经本地缓存了也要检查。 proxy-revalidata：表示共享缓存（CDN）必须要检查源是否存在，即使已经有缓存。 通过上面的具体解释，现在再来描述上面 Cache-Control 的那段代码所表达的意思就好理解多了： 本地缓存和 CDN 缓存均缓存 1 小时； 不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新； 不能缓存。如果一定要缓存的话，确保对其进行了二次验证； 本地缓存 1 小时，CDN 上缓存 2 小时； 本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源中文档是否已经被改变。 实例理论会很单调乏味，现在用短的实例来演示如何自动注入 ETag 和 Cache-Control 头。例子是一个 Apache 的 .htaccess 文件，但是我希望你能够领会要领，并且根据你自己的实际情况，应用到你自己的 Web 应用中。123456789101112# 为所有图片设置 ETag，以及缓存时间为 1 天&lt;FilesMatch &quot;\\.(gif|flv|jpg|jpeg|png|gif|swf)$&quot;&gt; FileETag -INode MTime Size Header set Cache-Control &quot;max-age=86400 public&quot;&lt;/FilesMatch&gt;# 为所有的 CSS 文件、JS 文件设置 ETag，以及缓存时间为 2 小时，同时保证进行了二次验证&lt;FilesMatch &quot;\\.(js|css)$&quot;&gt; FileETag -INode MTime Size Header set Cache-Control &quot;max-age=7200 public must-revalidate&quot; Header unset Last-Modified&lt;/FilesMatch&gt; 上面例子，是一个对 URL：http://www.foobar.tld/baz.jpg 的响应。包含了一个 ETag 头，由更改时间和文件大小所构成，还有 Cache-Control 头来设定缓存 1 天的时间。123456789101112# REQUESTGET /baz.jpg HTTP/1.1Host: www.foobar.tld# RESPONSEHTTP/1.1 200 OKDate: Tue, 07 Feb 2017 15:01:20 GMTLast-Modified: Tue, 07 Feb 2017 15:01:15 GMTETag: &quot;4-547f20501b9e9&quot;Content-Length: 123Cache-Control: max-age=86400 publicContent-Type: image/jpeg 对于 URL： http://www.foobar.tld/dist/css/styles.css 的响应同样也包含了 ETag 头。由更改时间、文件大小和限定了 2 小时的 Cache-Control 构成。Last-Modfied 头也删除掉以确保只有 ETag 用来做二次验证。123456789101112# REQUESTGET /styles.css HTTP/1.1Host: www.foobar.tld# RESPONSEHTTP/1.1 200 OKDate: Tue, 07 Feb 2017 15:00:00 GMTServer: ApacheETag: &quot;20-547f1fbe02409&quot;Content-Length: 32Cache-Control: max-age=7200 public must-revalidateContent-Type: text/css Cookies你已经知道了缓存头是如何起作用的，现在我们来看下在缓存里面 cookie 起了什么作用。首先， Cookie 的设定也在 HTTP 响应头中，名字是 Set-Cookie。设置一个 cookie 的目的是标识这个用户，就是说你需要为每个用户设置一个 cookie。 想象一下缓存的场景，你是否会缓存一个包含了 Set-Cookie的 HTTP 响应，在缓存时间内，每个人都会得到相同的 cookie 和同样的用户 session？你肯定不想这样。 另外，用户 session 状态的改变可能会影响到响应内容的变化。一个简单的场景：电商购物车。你给用户要么提供一个空购物车，要么是用户自己选了很多物品的购物车。同样的道理，你不希望这个也被缓存，毕竟每个用户都应该有自己的购物车。 一个解决方法是在运行时通过 JavaScript 设置 Cookie，比如 Google Analytics。GA 通过 JS 设置 cookie，但这个 cookie 既不影响渲染，也不设置 Set-Cookie 头。GA 会在目标网站上添加类似于 “you are tracked via Google Analytics” 的图标，但是只要这些改变都是在运行时添加进去的，就都没有问题。 正确处理 cookie 和缓存首先你需要知道你网站的 cookie 的工作原理。cookie 是不是只在特定时间使用（如在用户登录过程中使用）？原则上，cookie 是不是会被注入到所有响应？ 正如上一节所说的，不论何时服务器返回了一个带有 Set-Cookie 的响应，你都希望能够保证它不会被缓存。那么问题就转化成为，当你返回一个带有“用户特性”内容的响应时（如购物车），CDN /代理服务器，会作何操作？ 如果没设置 Set-Cookie，是不是允许缓存呢？ 如果设置了 Set-Cookie，是不是自动丢弃所有 Cache-Control 头呢？ 其实，如果从应用层面来讲，你尽管可以去实现你所喜欢的 web 应用就可以了，至于 cookie 和 CDN 都是自动设置的。还是用 Apache 的 .htaccess 来作为例子来解释：12345678# 1) 如果 cookie 没设置，允许缓存Header set Cache-Control &quot;public max-age=3600&quot; &quot;expr=-z resp(&apos;Set-Cookie&apos;)# 2) 如果 cookie 被设置，不允许缓存Header always remove Cache-Control &quot;expr=-n resp(&apos;Set-Cookie&apos;)# 2a) 第二条的另一种形式，如果设置了 cookie，缓存时间设置成0Header set Cache-Control &quot;no-cache max-age=0 must-revalidate&quot; &quot;expr=-n resp(&apos;Set-Cookie&apos;) 规则1：如果没设置 Set-Cookie，则给 Cache-Control 设置一个默认值； 规则2：如果设置了 Set-Cookie，则忽略 Cache-Control； 规则2a：是规则2的另一种表示形式，设置最大缓存时间是 0。 不设置 cookie 的访问路径一些 CMS /框架还在使用一种暴力的方式种 cookie。而实际上，决定是否种 cookie 取决于不同的因素，比如会话时间因素。如果你有一个很高安全性的 web 应用，设置会话时间是 5 分钟，那么为每个响应设置一个新 cookie 都不过分。而假设你的应用连“用户特性”都没有，也就是说所有的东西对所有用户都是公用的，那么设置任何形式的 cookie 都是没有道理的。 所以下面这个例子是否适合你自己，很大程度上依赖于你的应用到底是什么类型的。我们来一起看一下，我先给一下这个例子的上下文关系：假设你有个新网站，你的所有文章都在 http://www.foobar.tld/news/item/ 这个路径下面。现在你希望能够保证，所有访问 /news/item/&lt;ID&gt; 的路径都不包含 Set-Cookie，因为你确定不需要 cookie。12345678910# 通用 PHP 重定向做法，将&quot;?path=$1&quot;写到重定向规则里RewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.php?path=$1 [NC,L,QSA]RewriteRule ^$ index.php [NC,L,QSA]# 利用 query 中的 path= 来判断&lt;If &quot;%&#123;QUERY_STRING&#125; =~ m#path=news/item/[^&amp;]+#&quot;&gt; Header always unset Set-Cookie&lt;/If&gt; 通过这样的设置，你就可以保证所有访问 /news/item/&lt;ID&gt; 的路径都不包含 Set-Cookie。而到底是否应该设置 cookie，需要你根据你自己的应用特点来判断。 设计出来的缓存能力有很多设计方案可以使你的 web 应用具有高缓存性。鉴于本文仅仅是一篇文章而不是一本书，我不可能每个点都深入的来讲，但是我可以着重提一下通用的方法。 我还用电商作为例子。假设电商网站首页的 top 位置上展示了正在出售的物品，生成这些物品需要进行若干次的数据库操作，代价比较大，因此希望把它们缓存起来。但是，问题在于购物车，它是为那些登陆用户准备的，所以希望得到的结果是： top 物品是一样的，而针对登陆用户展示购物车。 那么优化策略首先要为每个用户提供一个和登陆状态无关的“通用”页。然后通过 JavaScript 为已经生成的网页提供购物车。站在用户的视角，最终展示形式是一样的。那么现在你有了两个请求（整个网页请求 + 购物车请求），而不是一个请求（整个网页请求，包含购物车）。ok，现在你可以把代价很大的部分，即 top 物品分离出来，把它们缓存起来了。 这种方法或者其延伸方法，不适合已经开发好的项目。因为它可能会改变很多接口和视图层（MVC 架构）的内容。最好你在一开始就设计好。 缓存失效：busting 和 purging使用 max-age 和 s-maxage 你已经可以很好地控制一个指定的响应被缓存多长时间。但是这不足以适用于所有的情况。这些设置都是在返回响应时预设的，而现实情况往往是并不知道一个响应应该设置多久期满。回想一下刚才电商首页的例子：假设它包含了展示在 top 位置的 10 个实体。你设置了 max-age=900给这个首页以保证每15分钟刷新一次。现在，其中 1 个实体由于发布了太久了要被撤销，那么你就需要把之前的缓存响应删掉，这时候其实还没到 15 分钟，那么该怎么办？ 不要担心，这是一个常见的问题，有很多方法解决。首先我们先来解释一下术语： 缓存 busting，是用来解决浏览器长期缓存问题，它通过版本标识来告诉浏览器该文件有一个新的版本。这时浏览器将不会从本地缓存取内容，而从源服务器请求新版本的文件。 缓存 purging，表示直接从缓存中删除内容（即响应），以使得缓存可以立马得到更新。 用于版本管理的缓存 busting这种方法经常使用在 CSS 文件、JS 文件上。通常一个确切的版本号、一串哈希或者时间戳都可以用作标识，如下面的例子： 数字版本号：style-v1.css，style.css?v=1 哈希串版本：style.css?d3b07384d113edec49eaa6238ad5ff00 时间戳版本：styles.css?t=1486398121 这时候在发布程序的时候，你只要注意文件的版本就可以了。举个例子，一个 HTML 网页通过 &lt;link rel=&quot;stylesheet&quot; href=&quot;..&quot;&gt; 这种形式包含了一个 CSS 文件。CSS 文件将会被缓存起来，这时如果你想让你的新 CSS 文件起作用，那么用最新的版本号命名它就可以。如果不做任何变化的话，即便你更新了文件，这个 HTML 还会使用缓存中的旧 CSS 文件。 缓存 purging不同 CDN 供应商清除缓存的方式不一样。很多供应商都是基于开源软件 Varnish 来构建自己的 CDN 服务，所以一个通用的做法是在 HTPP 请求中使用 PURGE 结构，如：12PURGE /news/item/i-am-obsolete HTTP/1.1Host: www.foobar.tld 使用这个请求通常需要权限认证，或者是源确认（即 IP 白名单），不过不同供应商的要求也不一样。 清除一个或几个缓存项比较容易，但是在某些场景下，却不是这么简单。举个例子，一个博客的场景，博客里面都有关于作者的部分，现在你要改变关于作者的一些内容，那么你需要手动清理所有包含了作者信息的页面。你确实可以一个一个手动清理，但是假设你有成千上万个网页被影响了，那问题就变得麻烦了。 下面介绍一个解决方案。 代理标签“代理标签” 这个名字来源于 CDN 供应商 Fastly，不同供应商给它起的名字不一样，比如还有叫它“缓存标签”的，Varnish 叫它 Hashtwo/Xkey，这里我就不详细介绍其他供应商的情况了。 不论它叫什么，它们的目的都是一样的：给响应打标签。这样你就可以轻松地从缓存中删除相关的标签就可以，甚至都不用知道缓存的到底是什么东西。 还是拿&lt;客户端-代理-源端&gt;来举例子，源端返回一个含有代理标签的响应：1234HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 123Surrogate-Key: top-10 company-acme category-foodstuff 这个例子中的标签为：top-10， company-acme，和 category-foodstuff。这里给一个电商的实际场景来理解其含义：这个响应包含了电商首页的前 10 个物品，这些物品由 ACME 公司提供，并且其目录类别都设定为食品类。 设置了标签以后，当物品发生了变化以后，你只需要删除包含有 company-acme 和 top-10 的标签就可以了。是不是很简单？ 同样，具体如何清除缓存的操作方法，不同 CDN 供应商是不一样的。 写在最后上面讨论的更多的是理论上的做法，还有很多文章专门介绍不同的 CDN 的使用。如果你想深入了解的话，下面的资料每篇可能都是你需要的。 谷歌开发者：HTTP 缓存 Push CDN 和 Pull CDN CDN 类型（管理员视角） 缓存头概览 缓存详解（Mozilla） ETag头详解（Mozilla） Cace-Control 头详解（Mozilla） If-None-Match 头详解（Mozilla） Fastly：代理标签 KeyCDN：缓存标签","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Service","slug":"前端笔记/Service","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Service/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://xiaoxiaoqdq.com/tags/HTTP/"},{"name":"CDN","slug":"CDN","permalink":"http://xiaoxiaoqdq.com/tags/CDN/"}]},{"title":"通过动图形象地为你介绍 Flexbox 是如何工作的（二）","slug":"cs-flexbox-works-2","date":"2017-03-11T15:18:00.000Z","updated":"2017-03-12T05:51:14.000Z","comments":true,"path":"/blog/cs-flexbox-works-2/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/cs-flexbox-works-2/","excerpt":"","text":"在上一篇文章中，我们介绍了 flexbox 的几个属性： flex-direction，justify-content，align-items 和 align-self。 这些命令在创建基本布局上是特别有用的。而一旦你开始用 flexbox 创建网站的时候，你需要对其进行深挖以最大化地发挥它的价值。 现在我们来深入学习一下 flexbox，并且告诉你如何利用它来构建一个漂亮的布局。 属性1：flex-basis上一篇文章中，主要介绍了应用在容器元素上的属性。这次我们专门介绍关于子元素的使用。 以我之见，我们要介绍的第一个属性，是 flexbox 教程里面解释的最少的属性之一。 但是不要担心，其实它很简单。 flex-basis 控制的是一个元素的默认尺寸，但是它可以被 flexbox 的其他属性所影响（稍后会详细介绍）。 下面这个 GIF 表示的是它和 width 这个属性是可以互换的。 然而，flex-basis 和 width 唯一不同的地方是，它是和 flex 坐标轴保持一致的。 flex-basis 是在主轴方向上影响元素大小的。 我们来看一下，当我们保持 flex-basis 不变的情况下，改变主轴方向，会发生什么。 这里要注意，原来设置的是 height 属性，现在必须要手动地设置为设置 width 属性。因此可以看到，flex-basis 依赖于 flex-direction 来影响 width 或者 height。 属性2：flex grow让我们继续学习，增加点复杂度。 首先，我们把所有的形状 width 都设置为120px： 现在我们来引出一个属性 flex-grow，它的默认值是 0。也就是说所有的形状没有被允许自动地填充整个容器。 这又是什么意思呢？让我们来看看，如果把各个形状的 flex-grow 设置成 1 会发生什么： 所有形状一起充满了整个容器的宽度，并且他们之间的间隙也都是相同的。也就是说 flex-grow 覆盖了 width。 那么令人疑惑的问题又来了，它的值具体表达什么意思呢？flex-grow: 1 意味着什么呢？ 为了解释这个问题，我们把每个形状的 flex-grow 值设置成 999，看一下效果： 可以看到，并没有变化。 这是因为：flex-grow 并不是一个绝对值，而是一个相对值。 对于每个元素来说，重要的不是 flex-grow 的值是多大，而是本元素的这个值和其他元素的这个值相比较，相对大小是怎么样的。 如果我们设置每个元素的 flex-grow: 1，而改变第三个形状的 flex-grow，我们可以看到下图的改变： 为了完全理解这个知识点，我们来快速地做一些简单的数学运算。 每个元素 flex-grow 的起始值都是 1。把所有元素的该值加起来，总和是 6。因此容器的总宽度被分成了 6 份。每个形状就被扩展到容器所有可用空间的 1/6。 然后设置第三个形状的 flex-grow 值为 2。那么容器的宽度被分成 7 等份，因为所有 flex-grow 属性是：1 + 1 + 2 + 1 + 1 + 1。 第三个形状占了整个容器空间的 2/7，其他的占了 1/7。 同理，当设置第三个形状的 flex-grow: 3 的时候，整个容器宽度被分成了 8 份（1 + 1 + 3 + 1 + 1 + 1），第三个形状占了 3/8,其他的占了 1/8。 以此类推。 flex-grow 只和比例相关，例如，设置第三个形状 flex-grow: 12，其余每个形状的 flex-grow: 4，可以和第三个设置成 3，其他的设置成 1得到同样的效果，见下图： 重点在于，每个形状的 flex-grow 和其他形状的是成比例的。 最后要提醒的是，要记住 flex-grow 和 flex-basis 类似，它也是应用在主轴上的。形状都会做宽度的改变，除非我们设置 flex-direction 为列。 属性3：flex shrinkflex-shrink 刚好和 flex-grow 相反，它是决定形状收缩多少的。 它只应用于元素必须要缩小以适应容器的情况，即容器太小了。 他的主要用法是指定哪个元素你想要缩小，哪个不想缩小。默认情况是每个形状都 flex-shrink: 1，这表示每个形状都会随着容器的缩小而缩小。 我们来在应用中看一下，在下面的 GIF 图中，每个形状的 flex-grow 都是 1，所以他们填满了整个容器。每个形状的 flex-shrink 也都是 1，所以它们也会像下面图中这样收缩。 那么现在，我们来设置第三个形状的 flex-shrink 值为 0。不允许它收缩，所以当它拉伸的时候，会随着容器拉伸，而当收缩的时候，不允许比他的 width 还小，即不允许比 120px 还小。 默认值是 1，表示元素默认允许收缩，除非你指定它为不允许。 同样，flex-shrink 是和比例相关的。如果设置一个形状的 flex-shrink 为 6,而其他的是 2，那么这个形状随着容器空间的压缩，将以 3 倍于其他形状的速度缩小。 这里尤其注意：是空间收缩的速度是 3 倍，而不是说他的宽度会缩小到原来的 1/3。 接下来我们要深入了解元素到底收缩或者拉伸了多少，不过首先，我们先回到上一个属性，把所有的知识串起来。 属性4：flexflex 是 grow，shrink 和 basis 的简化形式——把他们所有都放到了一起。 它的默认值是：0（grow），1（shrink）和 auto（basis）。 在我们的上一个例子中，我们用它来简化两个形状，下面是它们的属性：123456.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 两个有着相同的 flex-basis。也就是说如果有足够的空间（容器的空间等于 600px 加上边缘和内边距），他们每个的宽度将是 300px。 但是随着容器的拉伸，形状 1 （有更大的 flex-grow 值）将会以两倍的速度增长。随着容器的收缩，形状 2 （有更大的 flex-shrink 值）将会以两倍的速度压缩。 都放到一起展示，如下图： 元素是怎样收缩和拉伸的呢这里有个问题可能会使人疑惑：当形状 1 拉伸时，并没有拉伸到形状 2 的两倍大小。同样，当形状 2 缩小时，也并没有缩小到形状 1 的一半，尽管 flex-shrink 的比值是 2:1。 实际上它的意思，并不是说他们的大小是 2:1 或者 1:2，而是说它们的收缩率或拉伸率。 简单计算容器的初始大小是 640px。在除去容器要预留的 20px 的间距后，剩下的空间足够将两个形状恢复到 flex-basis 等于 300px。 当容器设置到了 430px 时，空间减小了 210px。形状 1，设置了 flex-shrink 是 1，减小了 70px。而形状 2，设置了 flex-shrink 是 2，减小了 140px。 当容器减小到 340px，容器空间减小了 300px。这是形状 1 减小 100px，而形状 2 减小 200px。 整体减小空间的分配方式，是按照各自设置的 flex-shrink 比例分配的（2:1）。 对于 flex-grow 是同样的计算方式。当容器拉伸到 940px 时，整体增加了 300px，形状 1 增加 200px，而形状 2 增加 100px。 当涉及到 flex 属性时，比例是主要考虑的对象。 从上图中，可以看到宽度是如何根据设置的比率变化的，其中的 delta (∆) 表示和原始 flex-basis 相比的变化量。 结论最后重述：flex-basis 指的是一个元素在发生伸缩之前，沿着主轴方向的大小。flex-grow 指的是在元素拉伸时，和兄弟元素相比的拉伸比例。flex-shrink 指的是在元素收缩时，和兄弟元素相比的收缩比例。 我们还有几个 flexbox 属性要讲，请留意随后几周的文章。 非常感谢你们，非常感谢每个花时间阅读、评论和分享的读者，你们的鼓励是我不断前行的动力！","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"CSS","slug":"前端笔记/CSS","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://xiaoxiaoqdq.com/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://xiaoxiaoqdq.com/tags/flexbox/"}]},{"title":"通过动图形象地为你介绍Flexbox是如何工作的（一）","slug":"cs-flexbox-works-1","date":"2017-03-11T15:02:00.000Z","updated":"2017-03-12T05:51:06.000Z","comments":true,"path":"/blog/cs-flexbox-works-1/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/cs-flexbox-works-1/","excerpt":"","text":"flexbox 承诺将我们从万恶的纯 CSS 中拯救出来（如垂直对齐）。 flexbox 也正在实现它的这一目标，但是用户掌握这一新的模型也将会是个挑战。 因此在这里，我们将会用动图介绍 flexbox 是如何工作的，使得我们可以用它来做更好的布局。 flexbox 的潜在原则是使得布局更加灵活和直观。 为了完成这一目标，它允许容器自己来决定如何均匀地分布其中的元素——包括他们的尺寸和他们之间的间距。 这理论上来讲，听起来很美好。但是让我们来看一下实践中会发生什么。 在这篇文章中，我们会钻研5个通用 flexbox 原则。会探索它们都做了什么？你可以如何使用它们？以及它们的结果是什么样的？ 属性1：display: flex 在一个灰色背景的容器div里面，有四个颜色不同、尺寸不同的子div，此时每个div有默认的display: block，每一个的宽度也占满了一整行。 为了使用 flexbox，需要将你的容器放在 flex 容器中 ，见如下代码：123#container &#123; display: flex;&#125; 可以看到，发生了一点变化。你的四个div显示到了一行上，但也就仅此而已。可是你要知道，在这背后，你做了一件很有 power 的事情。你赋予了你的 div 一个叫做 flex上下文 的东西。 你现在可以把它应用在你的上下文中了，是不是比传统的 CSS 简单很多！ 属性2：flex-direction一个 flexbox 容器有两个坐标轴：主轴和交叉轴，直观的来看如下图： 默认情况下，元素都是从左到右地分布在主轴上。这就是为什么当你应用display: flex的时候，形状默认水平分布的原因。 flex-direction，可以使你的主轴旋转。1234#container &#123; display: flex; flex-direction: column;&#125; 这里有一个很重要的区别：flex-direction: column并不是把你的形状分布在交叉轴上。而是使主轴自身发生了旋转，从水平方向旋转到了垂直方向。 还有一些其他的flex-direction可选项，如：row-reverse和column-reverse。 属性3：justify-contentjustify-content控制的是你在主轴上如何对齐元素。 这里我们需要对主轴和交叉轴的区别有更深一点的理解。首先让我们回到flex-firection: row。12345#container &#123; display: flex; flex-direction: row; justify-content: flex-start;&#125; 使用 justify-content，你有五个选择： flex-start flex-end center space-between space-around space-around和space-between是最直观的。space-between使每个元素之间有相同的距离，但是不包含元素和容器之间的距离。 space-around让每个元素块的两侧有相同的空隙距离。这就意味着最外层的元素和容器之间的距离，是两个元素之间距离的一半（每个元素块的左右两侧都贡献了一个不重叠的等距离，因此是两倍的间隙）。 最后小结：记住justify-content是沿着主轴的，flex-direction是转换主轴的。这对你以后移动元素很关键。 属性4：align-items如果你已经消化了justify-content，那么align-items对你俩讲将是轻而易举的事了。 justify-content是沿着主轴的，而align-items是应用到交叉轴上的。 调整flex-direction，使得坐标轴看起来和上面的图一样。 接下来，我们一起看一下align-items命令。 flex-start flex-end center stretch baseline 前三个和justify-content没什么区别，后两个则有一些不同。 stretch你的元素将会被拉伸充满整个交叉轴。baseline则会使你的文字底部对齐。见图知意。 （注意：如果用align-items: stretch，你必须要将元素的height设置成auto，否则height属性将会覆盖stretch） 对于baseline要意识到，如果你把文字标签拿掉，那么将会用元素的底部对齐来替代原来的效果，如下图。 为了更好的展示主轴和交叉轴，我们结合justify-content和align-items来看一下两个flex-direction的核心不同。 用row，元素被分布在水平主轴上。用column，被分布在垂直主轴上。 在这两个 case 中，不论垂直还是水平方向，四个元素都是被居中的，但是这两种情况是绝对不能互相替换的。 属性5：align-selfalign-self允许你手动操作一个特定元素的对齐方式。 对于一个元素而言，它基本上是对align-items的覆盖。尽管align-self默认值设成了auto，但是它和align-items所有的属性都是一样的，这也使得这个元素继承了容器的align-items。1234567#container &#123; align-items: flex-start;&#125;.square#one &#123; align-self: center;&#125;// 只有这个形状会居中。 我们来看一下它设置的结果是什么样的。对前两个形状设置不同的align-self，其他元素设置为align-items: center和flex-direction: row。 结论尽管我们仅仅讲了 flexbox 的皮毛，但是这些命令应该也足够你应付很多基本布局了。 如果你还想看到更多的 GIF flexbox 教程，或者这篇教程对你有所帮助，请在下面给我点赞吧，或者给我留言。 感谢你的阅读！","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"CSS","slug":"前端笔记/CSS","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://xiaoxiaoqdq.com/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://xiaoxiaoqdq.com/tags/flexbox/"}]},{"title":"无循环 JavaScript","slug":"js-without-loops","date":"2017-03-11T14:52:00.000Z","updated":"2017-03-12T08:38:24.000Z","comments":true,"path":"/blog/js-without-loops/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-without-loops/","excerpt":"","text":"之前有讨论过，缩进导致了代码复杂性的增加（以粗鲁的方式）。我们的目标是写出复杂度低的 JavaScript 代码。通过选择一种合适的抽象来解决这个问题，可是你怎么能知道选择哪一种抽象呢？很遗憾的是到目前为止，没有找到一个具体的例子能解释这一问题。这篇文章中我们讨论不用任何循环如何处理 JavaScript 数组，最终得出的效果是得到低复杂度的代码。 循环是一种很重要的控制结构，它很难被重用，也很难插入到其他操作之中。另外，它意味着随着每次迭代，代码也在不断的变化之中。——Luis Atencio 循环我们先前说过，像循环这样的控制结构引入了复杂性。但是至今也没能很好的解释这是如何发生的。那么我们首先来看一下在 JavaScript 中循环是如何起作用的。 在 JavaScript 中，至少有四、五种实现循环的方法。最基础的是 while 循环。首先，先创建一个示例函数和数组。1234567891011// oodlify :: String -&gt; Stringfunction oodlify(s) &#123; return s.replace(/[aeiou]/g, 'oodle');&#125;const input = [ 'John', 'Paul', 'George', 'Ringo',]; 现在有了一个数组，我们想要用 oodlify 函数处理每一个元素。如果用 while 循环，就类似于这样：123456789let i = 0;const len = input.length;let output = [];while (i &lt; len) &#123; let item = input[i]; let newItem = oodlify(item); output.push(newItem); i = i + 1;&#125; 注意看好每一步，首先用了一个计数器 i，把这个计数器初始化为 0，然后在每次循环中将其自增。每次必须要和 len 进行比较以保证它在那里停下来。这种方式太有共性了，所以 JavaScript 提供了一个更简单的实现方式： for 循环，写起来如下：1234567const len = input.length;let output = [];for (let i = 0; i &lt; len; i = i + 1) &#123; let item = input[i]; let newItem = oodlify(item); output.push(newItem);&#125; 这一结构非常有用，它把所有的计数器引用都放到了最上面，而 while 循环非常容易把自增的 i 给忘掉，进而引起无限循环。这确实是一个改进，但是重新思考一下这个问题。我们想要达到的目标是在数组的每个元素上运行 oodlify() 函数，并且将结果放到一个新的数组中，我们并不关心计数器的问题。 对一个数组中每个元素都进行操作的这种模式也是非常普遍的。因此，在 ES2015 中，有了一种新的循环结构，这种循环结构可以丢弃掉计数器： for...of 循环。每一次返回数组的下一个元素给你，代码如下：12345let output = [];for (let item of input) &#123; let newItem = oodlify(item); output.push(newItem);&#125; 这样就清晰很多，注意这里计数器和比较都不用了，甚至都不用将数组里的元素做一步额外的取出操作。for...of 帮我们做了里面的脏活累活。到此为止，我们用 for...of 来代替 for 循环，可以很大程度上降低复杂性。但是，我们还可以进一步优化它。 mappingfor...of 循环比 for 循环更清晰，但是依然需要一些设定性的代码。如不得不初始化一个 output 数组并且每次循环都要调用 push() 函数。但是如何解决这个问题，我们不妨先来扩展一下问题。 如果有两个数组需要调用 oodlify 函数会怎么样？12345678910111213141516const fellowship = [ 'frodo', 'sam', 'gandalf', 'aragorn', 'boromir', 'legolas', 'gimli',];const band = [ 'John', 'Paul', 'George', 'Ringo',]; 很直观的想法是为每个数组做循环：1234567891011let bandoodle = [];for (let item of band) &#123; let newItem = oodlify(item); bandoodle.push(newItem);&#125;let floodleship = [];for (let item of fellowship) &#123; let newItem = oodlify(item); floodleship.push(newItem);&#125; 这确实ok。有能正确执行的代码，就比没有好。但是，这是重复性的工作——不够“DRY”。我们来重构它以降低它的重复性，创建一个函数：1234567891011function oodlifyArray(input) &#123; let output = []; for (let item of input) &#123; let newItem = oodlify(item); output.push(newItem); &#125; return output;&#125;let bandoodle = oodlifyArray(band);let floodleship = oodlifyArray(fellowship); 这看起来好多了，可是如果我们想使用另外一个函数该怎么办？123function izzlify(s) &#123; return s.replace(/[aeiou]+/g, 'izzle');&#125; 上面的 oodlifyArray() 将不起作用了。可是如果再创建一个 izzlifyArray() 函数的话，那就又变成重复的问题了。先不管那么多，我们先将他们并排写出来：1234567891011121314151617function oodlifyArray(input) &#123; let output = []; for (let item of input) &#123; let newItem = oodlify(item); output.push(newItem); &#125; return output;&#125;function izzlifyArray(input) &#123; let output = []; for (let item of input) &#123; let newItem = izzlify(item); output.push(newItem); &#125; return output;&#125; 这两个函数惊人的相似。那么我们是不是可以把他们抽象成一个通用的模式呢？我们想要的是：给定一个函数和一个数组，通过这个函数，把数组中的每一个元素做操作后放到新的数组中。我们把这个模式叫做 map 。一个数组的 map 函数如下：1234567function map(f, a) &#123; let output = []; for (let item of a) &#123; output.push(f(item)); &#125; return output;&#125; 当然，这里并没有完全脱离循环。如果想要脱离循环的话，可以做一个递归的版本出来：1234function map(f, a) &#123; if (a.length === 0) &#123; return []; &#125; return [f(a[0])].concat(map(f, a.slice(1)));&#125; 递归解决方法非常优雅，仅仅用了两行代码，并且只有很少的缩进。但是通常我们并不倾向于使用递归，因为它在较老的浏览器中的性能非常差。实际上，我们并不是非得自己写 map（除非我们自己想写）。map 模式非常有共性，因此 JavaScript 提供了一个内置 map 方法。使用这个 map 方法，上面的代码变成了这样：1234let bandoodle = band.map(oodlify);let floodleship = fellowship.map(oodlify);let bandizzle = band.map(izzlify);let fellowshizzle = fellowship.map(izzlify); 可以注意到，缩进消失，循环消失。诚然，循环可能转移到了其他地方，可是这并不是我们所关心的。我们的代码现在变得简洁而富有表达张力。 为什么这个代码这么简单呢？这可能是个很傻的问题，不过也请思考一下。是因为短吗？不是，短并不代表不复杂。它很简单，是因为我们把问题分离了。有两个处理字符串的函数： oodlify 和 izzlify，这些函数并不需要知道关于数组或者循环的任何事情。同时，有另外一个函数： map ，它来处理数组，它不需要知道数组中元素是什么类型的，甚至你想对数组做什么也不用关心。它只需要执行我们所传递的函数就可以了。我们从对数组的处理中，把对字符串的处理分离出来，而不是把它们都混在一起。这就是为什么我们说上面的代码很简单。 reducing现在，map 已经得心应手了，但是这并没有覆盖到可能需要的每一种循环。只有当你想创建一个和输入数组同样长度的数组时才有用。但是如果你想要向数组中增加几个元素呢？或者想找一个列表中的最短字符串是哪个？其实有时我们对数组进行处理，最终只想得到一个值而已。 来看一个例子，现在有一个关于英雄的数组：1234567891011const heroes = [ &#123;name: 'Hulk', strength: 90000&#125;, &#123;name: 'Spider-Man', strength: 25000&#125;, &#123;name: 'Hawk Eye', strength: 136&#125;, &#123;name: 'Thor', strength: 100000&#125;, &#123;name: 'Black Widow', strength: 136&#125;, &#123;name: 'Vision', strength: 5000&#125;, &#123;name: 'Scarlet Witch', strength: 60&#125;, &#123;name: 'Mystique', strength: 120&#125;, &#123;name: 'Namora', strength: 75000&#125;,]; 我们想找最强壮的英雄。使用 for...of 循环，像这样：123456let strongest = &#123;strength: 0&#125;;for (hero of heroes) &#123; if (hero.strength &gt; strongest.strength) &#123; strongest = hero; &#125;&#125; 虽然这个代码可以正确运行，可是实在太烂了。看这个循环，每次都保存到目前为止最强的英雄。继续提需求，接下来我们想要所有英雄的组合强度值：1234let combinedStrength = 0;for (hero of heroes) &#123; combinedStrength += hero.strength;&#125; 在这两个例子中，都在循环开始之前初始化了一个变量。然后在每一次的循环中，处理一个数组元素，并且更新这个变量。为了使循环变得清晰，现在把数组中间的部分进行重构，重构到函数中。我们要重命名这些变量，以进一步突出相似性。123456789101112131415161718192021function greaterStrength(champion, contender) &#123; return (contender.strength &gt; champion.strength) ? contender : champion;&#125;function addStrength(tally, hero) &#123; return tally + hero.strength;&#125;const initialStrongest = &#123;strength: 0&#125;;let working = initialStrongest;for (hero of heroes) &#123; working = greaterStrength(working, hero);&#125;const strongest = working;const initialCombinedStrength = 0;working = initialCombinedStrength;for (hero of heroes) &#123; working = addStrength(working, hero);&#125;const combinedStrength = working; 写到这，两个循环变得非常相似了。它们两个之间唯一的区别是调用的函数和初始值不同。两个的功能都是对数组进行处理，最终得到一个值。所以，我们创建一个 reduce 函数来封装这个模式。1234567function reduce(f, initialVal, a) &#123; let working = initialVal; for (item of a) &#123; working = f(working, item); &#125; return working;&#125; reduce 模式在 JavaScript 中也是非常通用，因此 JavaScript 为数组提供了内置的方法，不需要自己来写。通过内置方法，代码就变成了：12const strongestHero = heroes.reduce(greaterStrength, &#123;strength: 0&#125;);const combinedStrength = heroes.reduce(addStrength, 0); ok，如果你认真思考，你会注意到上面的代码其实并没有短很多。不过也确实比自己手写的 reduce 代码少写了几行。但是我们的目标并不是使代码变短或者少写，而是降低复杂度。那么，我们降低了复杂度了吗？我会说是的。我们把处理个体的循环代码给分离了出去，现在的代码具有很少的耦合性，即很少的互相调用，复杂度得以下降。 reduce 方法乍一看可能觉得非常基础。关于 reduce 的例子大部分也都很简单，比如做加法。但是没有人说 reduce 方法只能返回基本类型，它可以是一个 object 类型，甚至可以是另一个数组。当我首次意识到这个问题的时候，自己也是豁然开朗。所以我们其实可以用 reduce 方法来写 map 或者 filter，这里我把这个任务留给你们自己来尝试。 filtering现在我们有了 map 处理数组中的每个元素，有了 reduce 处理数组维度，经过计算降到只得到一个值。但是如果想获取数组中的某些元素该怎么办？我们来进一步探索，现在增加一些属性到上面的英雄数组中：1234567891011const heroes = [ &#123;name: 'Hulk', strength: 90000, sex: 'm'&#125;, &#123;name: 'Spider-Man', strength: 25000, sex: 'm'&#125;, &#123;name: 'Hawk Eye', strength: 136, sex: 'm'&#125;, &#123;name: 'Thor', strength: 100000, sex: 'm'&#125;, &#123;name: 'Black Widow', strength: 136, sex: 'f'&#125;, &#123;name: 'Vision', strength: 5000, sex: 'm'&#125;, &#123;name: 'Scarlet Witch', strength: 60, sex: 'f'&#125;, &#123;name: 'Mystique', strength: 120, sex: 'f'&#125;, &#123;name: 'Namora', strength: 75000, sex: 'f'&#125;,]; ok，现在有两个问题，我们想要： 找到所有的女性英雄； 找到所有能量值大于500的英雄。 使用普通的 for...of 循环，会得到如下代码：12345678910111213let femaleHeroes = [];for (let hero of heroes) &#123; if (hero.sex === 'f') &#123; femaleHeroes.push(hero); &#125;&#125;let superhumans = [];for (let hero of heroes) &#123; if (hero.strength &gt;= 500) &#123; superhumans.push(hero); &#125;&#125; 上面代码运行起来没有问题，是不是看起来还不错？但是里面又出现了重复的情况。实际上，区别在于 if 的判断语句，那么能不能把 if 语句重构到一个函数中呢？123456789101112131415161718192021function isFemaleHero(hero) &#123; return (hero.sex === 'f');&#125;function isSuperhuman(hero) &#123; return (hero.strength &gt;= 500);&#125;let femaleHeroes = [];for (let hero of heroes) &#123; if (isFemaleHero(hero)) &#123; femaleHeroes.push(hero); &#125;&#125;let superhumans = [];for (let hero of heroes) &#123; if (isSuperhuman(hero)) &#123; superhumans.push(hero); &#125;&#125; 这种只返回 true 或者 false 的函数，我们一般把它称作 谓词。这里用了谓词来判断是否保存当前的英雄元素项。 上面代码的写法会看起来比较长。但是这样的重构很好地避免了之前的代码重复问题。可以进一步地抽象到一个函数中。1234567891011function filter(predicate, arr) &#123; let working = []; for (let item of arr) &#123; if (predicate(item)) &#123; working = working.concat(item); &#125; &#125;&#125;const femaleHeroes = filter(isFemaleHero, heroes);const superhumans = filter(isSuperhuman, heroes); 同 map 和 reduce 一样，JavaScript 提供了一个内置数组方法，没必要自己来实现（除非你自己想写）。用内置数组方法，上面的代码就变成了：12const femaleHeroes = heroes.filter(isFemaleHero);const superhumans = heroes.filter(isSuperhuman); 为什么这段代码比 for...of 循环好呢？回想一下整个过程，我们要解决一个“找到满足某一条件的所有英雄”。使用 filter 使得问题变得简单化了。我们需要做的就是通过写一个简单函数来告诉 filter 哪一个数组元素要保留。不需要考虑数组是什么样的，以及繁琐的中间变量。取而代之的是一个简单的谓词函数，仅此而已。 与其他的迭代器相比，使用 filter 是一个出小力办大事的过程。我们不需要通读循环代码来理解到底要过滤什么，要过滤的东西就在传递给他的那个函数里面。 findingfilter 已经信手拈来了吧。这时如果只想找一个英雄该怎么办？比如找 “Black Widow”。使用 filter 会写出如下代码：12345function isBlackWidow(hero) &#123; return (hero.name === 'Black Widow');&#125;const blackWidow = heroes.filter(isBlackWidow)[0]; 这段代码的问题是效率不够高。filter 会检查数组中的每一个元素，而我们知道这里面只有一个 “Black Widow”，当找到她的时候就可以停住，不用再看后面的元素了。那么，依旧利用谓词函数，我们写一个 find 函数来返回第一次匹配上的元素。123456789function find(predicate, arr) &#123; for (let item of arr) &#123; if (predicate(item)) &#123; return item; &#125; &#125;&#125;const blackWidow = find(isBlackWidow, heroes); 同样地，JavaScript 已经提供了这样的方法：1const blackWidow = heroes.find(isBlackWidow); 至此为止，find 再次体现了出小力办大事的原则。通过 find 方法，把问题简化为：你只要关注如何判断你要找的东西就可以了。不必关心迭代器到底怎么实现等细节问题。 总结这些迭代器函数的例子很好地诠释了为什么“抽象”非常有用。回想一下我们所讲的内置方法，每个例子中我们都做了三件事： 避免循环结构，使得代码变的简洁易读； 通过适当的方法名称来描述我们使用的模式，也就是：map，reduce，filter 和 find； 把问题从处理整个数组简化到处理每个元素。 这里要注意的是，我们把每个问题都打散，用一个或几个纯函数来解决。而真正令人兴奋的是仅仅通过 4 个模式（当然还有其他的模式，也建议大家去学习一下），在 JS 代码中你就可以消除几乎所有的循环了。这是因为 JS 中几乎每个循环都是用来处理数组，或者生成数组的。通过消除循环，降低了复杂性，也使得代码的可维护性更强。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoxiaoqdq.com/tags/JavaScript/"}]},{"title":"Web前端开发工程师编程能力飞升之路","slug":"ms-beginner","date":"2017-03-10T05:32:00.000Z","updated":"2017-03-11T02:12:28.000Z","comments":true,"path":"/blog/ms-beginner/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/ms-beginner/","excerpt":"","text":"最近在网上看到这篇“Web前端开发工程师编程能力飞升之路”的文章，受益颇深，故转载到博客中，勉励自己。作者把前端技术按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级，每个级别都提供了进阶之路，帮助在该等级迷茫的人们早日突破自己，更上一层楼。 背景如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧； 如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧； 如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧； web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！ 前言所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。 本文将web前端研发编程能力划分了八个等级，每个等级都列举出了对应的特征及破级提升之方法，希望每位在看本文的同学先准确定位自己的等级（不要以你目前能力的最高点，而是以你当前能力的中档与之等级作对比，以免多走弯路），参考突破之法破之。 所谓的级别，只是你面对需求时的一种态度：能够完成、能够完美地完成、能够超出预期地完成。以追求完美的态度加以扎实的编程功力，那就是你的编程水平。 切记心浮气燥，级别够了，那级别里的东西自然就懂了。悟了就是悟了，没悟也没关系，静下心来，投入时间而已。 一、入门能够解决一些问题的水平。有一定的基础（比如最常见的html标签及其属性、事件、方法；最常见的css属性；基础的javascript编程能力），能够完成一些简单的web前端研发需求。 举个例子：删除一字符串中指定的字符。 12345var str=\"www.baidu.com/?page\";str=str.replace('?page',\"\");alert(str);str=str.substring(0,str.indexof(\"/\"));alert(str); 首先不要苛责代码的对错严谨，毕竟每个程序员都有这样的一个过程；其次，这两段代码在这个实例里没有什么大过错，可能会有瑕疵，但能够解决问题（删除指定的字符），这就是这个级别的特征。 再举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 计算系统当前是星期几var str = \"\";var week = new date().getday();if (week == 0) &#123; str = \"今天是星期日\";&#125; else if (week == 1) &#123; str = \"今天是星期一\";&#125; else if (week == 2) &#123; str = \"今天是星期二\";&#125; else if (week == 3) &#123; str = \"今天是星期三\";&#125; else if (week == 4) &#123; str = \"今天是星期四\";&#125; else if (week == 5) &#123; str = \"今天是星期五\";&#125; else if (week == 6) &#123; str = \"今天是星期六\";&#125;// 或者更好一些var str1 = \"今天是星期\";var week = new date().getday();switch (week) &#123; case 0 : str1 += \"日\"; break; case 1 : str1 += \"一\"; break; case 2 : str1 += \"二\"; break; case 3 : str1 += \"三\"; break; case 4 : str1 += \"四\"; break; case 5 : str1 += \"五\"; break; case 6 : str1 += \"六\"; break;&#125;alert(str);alert(str1); 入门”阶段是每个程序员的必经之路，只要”入门”，你就上路了。所谓”师傅领进门，修行靠个人”，有了这个”入门”的基础，自己就可以摸索着前进了。 进阶之路将javascript、html、css之类的编码帮助手册里的每个方法/属性都通读几遍！只有将基础打好，以后的路才能走的顺畅。参考这些帮助文档，力争写出无瑕疵的代码。 这些编码文档建议不仅是在入门提高期看，在你以后每个阶段破阶的时候都应该看看，最基础的东西往往也是最给力的东西，有时能够给你带来意想不到的收获。 二、登堂能够正确地解决问题。不管你是通过搜索网络，或者通过改造某些成品代码（jquery/dojo/ext/yui）案例，只要能够无错地完成需求。 同样以上面的那段”字符串剪裁”代码为例： 123var str=\"www.baidu.com/?page\";str=str.replace(/?page/,\"\");alert(str); 仅仅解决问题对于”登堂”阶段来说已经不是问题，这个级别所给出方案不能是漏洞百出。以上面这段代码为例：replace方法的第一个参数虽然可以支持字符串，但最佳的类型是正则表达式； 1234var a = new array(\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\");var week = new date().getday();var str = \"今天是星期\"+ a[week];alert(str); 对比”入门级”的代码，不管是从代码量、代码效率、代码优美性、代码思路来说，”登堂”级的这个日期处理代码都要优秀很多。 进阶之路这个阶段虽然能够给出正确的解题方案，但是不一定是最优秀的方案。如何才能得到最优秀的方案呢？首先就是积累各种能够解决需求的方案，然后再验证每个方案，在这些方案中选择最好的一种。因此该阶段的进阶之路就是”行万里路，看万卷书”，积累各个需求的各个解决方案。 你可以扎身在专业论坛（蓝色理想、无忧、csdn）里，通读所有的faq及帖子；你可以打开搜索引擎，穷举所有的搜索结果。自己建立测试环境一一验 证这些代码：去揣摩每段代码的意图，去比较每段代码之间的差异。这两条路可以让你快速完成原始积累，当你再面对大多数需求时能够说这些问题我以前做过，那 你就水到渠成地晋阶了。 三、入室最强代码，知道所有能够解决需求的各种方案，能够选择使用最优秀的方案满足需求。这个级别基本上产品开发编程中的代码主力。给出的一招一式，招招都是绝招。 还以上面的那个例子为例，你能说出1、2、3之间的差别，以及适用于那种环境吗？ 1234567var str=\"www.baidu.com/?page\";// 1、字符串剪裁str.substring(0, str.indexof(\"?page\"));// 2、正则表达式str.replace(/?page/, \"\");// 3、字符串分拆、合并str.split(\"?page\").join(\"\"); 能够解决问题的方法会有很多，但是对于程序员来说应该选择最优秀的。上面这段代码从代码量来说”正则表达式”最优秀；从代码执行效率来说： “字符串剪裁”法最高（chrome中”正则表达式”效率最高），split法最次；从可扩展性上来说，”正则表达式”法最优。具体使用那种方案视具体的 需求环境而定。 “入室”阶段，程序员应该能够肯定的回答：对于这个需求而言，我的代码就是最优秀的代码。 再以”今天是星期几”为例，”登堂”级的代码你敢说是最优秀的代码了吗？ 12// 计算系统当前是星期几var str = \"今天是星期\" + \"日一二三四五六\".charat(new date().getday()); 对比”登堂”级的示例代码，上面这段代码给你什么感受？程序员追求的就是完美。”入室”级别追求的就是每一招每一式的完美无缺。 从web前端编程来说，通过2年左右的努力，很多人能够达到这个水平，但是，很大一部分人的编程能力也就止步于此。或限于产品的需求单一性，或限于需求开发的时间紧迫性，或限于人的惰性，能够完美地解决当前的需求就够了。 由于长期处于技术平台期，技术上得不到提高，通常这个级别的工程师会比较燥。技术上小有所成；或追求个人的突破；或追求产品差异性带来的新鲜感；或者只是想换个心情；因此很多此级别的工程师会经常换公司。 戒骄戒躁： 切勿以为自己能写一手漂亮的代码而自满； 切莫以为别人”尊称”你一声”大侠”你就以 “大侠”自居； 切莫以为自己积累了一些得意的代码就成了框架式开发。 细节决定成败，优秀的方案并不能保证最终的成功。还以”删除指定字符串”为例，原始字符串从格式上来看应该是了个url链接，在去除”pn=0″之 后，最末尾处留了一个尾巴”?”；如果原始字符串是”http://www.xxx.com/?pn=0&amp;a=1″，去除”pn=0″之后 ? 和 &amp; 两个符号紧贴一起，这更是明显的bug。 进阶之路此阶段进阶之路就是：切勿心浮气躁；你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。 再通读几遍html/css/javascript帮助文档。 我建议这个级别的工程师做一做webtreeview控件，要求总节点量一万左右操作流畅，你的晋升之路就在这个控件的编码过程中。 四、入微最强解决方案。你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及前端编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。 123456789101112131415161718192021var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0// 我将这个字符串里所可能想到的各种情况都列举出来var a = [ \"http://www.xxx.com/vmpn=?pn=0\"// pn= 可能出现在 ? 前 , \"http://www.xxx.com/vmpn=?pn=\"// url里允许pn 值为空 , \"http://www.xxx.com/vmpn=?pn=0&amp;a=1\"// url 里可有多个字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0\"// 可能排在最后 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1\"// 可能有多个 pn 字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=2\"// 可能在中间 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1&amp;b=1\" // 可能在中间成组 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=1&amp;pn=1\" // 可能零星分布];/* 需求的不言之秘：? 若出现在字符串最尾则要去之? &amp; 两个符号不可重叠*/var reg = /((\\?)(pn=[^&amp;]*&amp;)+(?!pn=))|(((\\?|&amp;)pn=[^&amp;]*)+$)|(&amp;pn=[^&amp;]*)/g;for (var i = 0; i &lt; a.length; i++) &#123; alert(a + \"\\n\" + a.replace(reg, \"$2\"));&#125; 这个阶段已经不再追求一招一式，对你来说不是使用什么创新绝招解决需求，而是给出成熟稳重的方案，从根上解决问题。针对某个当前需求你的代码可能不是最优，但是针对此类的需求你的代码却是最优秀的代码。 进阶之路很多web前端研发工程师在做了3-4年之后就会进入一个瓶颈期：产品开发需求是小菜一碟，没有新鲜的可以挑战的东西；代码开发中的稀奇的解题方法 都已经尝试过。没有了可挑战的难题，失去了探索的激情，也就没有了再上升的动力，好不容易走过”入室”级别的人又会有八九成止步于此。或转做技术领导人， 或转到其它的领域，或换公司。 这些人的上升之路在哪里呢？ 这个阶段单单依靠技巧和数量的累积已经没有什么效果了，突破之路在第5层《化蝶》里会详细说明，我建议你在这个阶段末尾着重关注编程理论：面向对象/过程、代码组织形式、编译、代码规范、其它的框架设计等等。 我建议这个级别的工程师做一做webeditor控件，不要求完整功能，但是该控件里的模块划分、代码组织、编程思想做到位，给出一个系统的解决方案。 五、化蝶破茧重生，这个层次关注的是编程语言本身，而不再关心产品需求。什么是茧？产品需求就是茧。当你一招胜万招，打遍天下需求之时，你如果还拘泥于需求开发，那就是你限于茧中而不自知。要么就在这个茧里默默地老去，要么就破开茧获得新生。 还是以那个”字符串剪裁”的老例子： 1234567891011121314151617181920212223242526272829/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author:meizz* @version: 2010/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/function escapereg(str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/function delurlquery(url, key) &#123; key = escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0delurlquery(str, \"pn\"); 这段代码相对于层次4《入微》有什么区别吗？从代码实现上来说没有太大的区别，但是从思路上来说却有着本质的区别：1、不再是就事论事，头疼医头，而是把一类问题抽象理论化，一招破万招；2、有封装的概念，不再是每次从零开始，而是站在半山腰开始爬。 在web前端研发队伍里也有很大一部分人《入室》层次时就自我感觉良好，直接跨跃到《化蝶》，积累自己的代码库，抽象化问题。但没有基础，缺少强大 的后劲，即使能够破茧也经受不了风吹雨打。一份不成熟的架构设计对团队开发带来的危害远大于它带来的好处，这种例子在业界屡见不鲜。不要拔苗助长，不要不 会走就想着跑，夯实基础，水到渠成地成长，厚积薄发，强力地破茧而出。 进阶之路你已经从原始积累，到厚积薄发，到破茧而出之后，你所关注的应该不再是一招一式、一个项目、一个模块，而应该是一种思路，一种理论。你可以做以下几 个步骤以突破到更高层次：再仔细看几遍html/css/javascript接口帮助文档；选择一门强语言（c++/c#/java等）观察理解这些语 言的组织结构，语言设计；看看原型链，链式语法编程，泛型，接口编程，dom遥控器等等；仔细阅读成熟的web前端开发框架的设计文档，看他们为什么要这 样设计。 六、大侠这里所说的大侠，不是大家互相吹捧的”大侠”，而是实至名归的高手。这个级别的人完全有能力写出不差于bindows/jquery/ext/yui/dojo的同等级别规模的前端开发框架。应用成熟的开发框架指导、解决问题。 123456789101112131415161718192021222324252627282930313233// 库文件 /mz/string/escapereg.js/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author:meizz* @version: 2010/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/mz.string.escapereg = function (str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125;// 库文件 /mz/url/delquery.js/// include mz.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/mz.url.delquery = function (url, key) &#123; key = mz.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例/// include mz.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0mz.url.delquery(str, \"pn\"); 自成体系，有基础，也有理论高度。知道为什么这样设计，也知道什么样的设计最好。比如这个例子可以有这样的封装： 123456789101112131415161718192021// 库文件 /mz/url/delquery.js/// include mz.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/string.prototype.delquery = function ( key) &#123; key = mz.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return this.replace(reg, \"\\x241\")&#125;// 应用实例/// include mz.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0str.delquery(\"pn\"); 而为什么不采用下面的那种封装呢？经过了《知微》和《化蝶》你就懂了。 进阶之路道法自然，从根上去寻找突破的契机。你可以研读html解析引擎设计与实现，js解析引擎设计与实现，其它语言的代码解析与编译实现等等。 或者出些书。低级别的人写的书要么是一大抄，空无一物；要么是害人。 七、宗师这个级别的人已然到了无招胜有招的境界。项目开发中的难题？没有难题！运行平台的差异？从根本上搞定！代码规范、开发模式，早已经被抛在身后。这个级别的人已经不再关注于某个前端开发框架，而是应对具体的环境给出最佳的理论指导。 这个级别的人所注意的应该是以最合理的系统架构引领着整个团队的进步，在什么样的场景下该用什么样的架构设计。3个、10个、50个、100个人的团队最应该用哪种模式？等你到了宗师级别，你再来回答吧。 进阶之路每一个宗师就是一个高山，就是一个领域里的神，但是你仅满足于在一群比你弱的群体展现你的强大吗？如果还你是止步原地，那总会有人乘着飞机、宇宙飞船从你的头领掠过，高处不胜寒！ 要突破这片领域，那就必须跳出这片领域。要想突破web前端研发的宗师级，那就跳出web前端吧，上面还有web开发。即使你是web前端的宗师， 但没有快速的数据响应，没有高速的网络架构，没有优美的系统支持，你又能如何？所以突破之路就是把目光投到整条web开发的链条中去。 八、飞升其实严格来说，飞升已经不是原领域的范围了。在web研发领域，对于这个层次的有一个很好听的称谓：架构师。当然那些”伪架构师”另当别论。 一法通，万法通。在其它的技术领域，也可以按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级；一样也可以按照我这里所写的每个级别的【进阶之路】来快速提升。 祝贺你再获辉煌！ 看完这篇文章，只能说自己的进步空间还很大，前端路漫漫，一起加油！ 原文链接未找到。再次感谢原文作者！","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"http://xiaoxiaoqdq.com/categories/面试宝典/"}],"tags":[{"name":"前端工程师","slug":"前端工程师","permalink":"http://xiaoxiaoqdq.com/tags/前端工程师/"}]}]}