{"meta":{"title":"笑笑前端圈","subtitle":"纯净前端知识分享平台","description":null,"author":"Xiaoxiao","url":"http://xiaoxiaoqd.com"},"pages":[{"title":"about","date":"2017-03-10T05:26:24.000Z","updated":"2017-03-10T05:26:46.648Z","comments":true,"path":"about/index.html","permalink":"http://xiaoxiaoqd.com/about/index.html","excerpt":"","text":"about us"}],"posts":[{"title":"Web前端开发工程师编程能力飞升之路","slug":"ms-beginner","date":"2017-03-10T05:32:00.000Z","updated":"2017-03-11T02:12:26.526Z","comments":true,"path":"/blog/ms-beginner/","link":"","permalink":"http://xiaoxiaoqd.com//blog/ms-beginner/","excerpt":"","text":"最近在网上看到这篇“Web前端开发工程师编程能力飞升之路”的文章，受益颇深，故转载到博客中，勉励自己。作者把前端技术按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级，每个级别都提供了进阶之路，帮助在该等级迷茫的人们早日突破自己，更上一层楼。 背景如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧； 如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧； 如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧； web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！ 前言所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。 本文将web前端研发编程能力划分了八个等级，每个等级都列举出了对应的特征及破级提升之方法，希望每位在看本文的同学先准确定位自己的等级（不要以你目前能力的最高点，而是以你当前能力的中档与之等级作对比，以免多走弯路），参考突破之法破之。 所谓的级别，只是你面对需求时的一种态度：能够完成、能够完美地完成、能够超出预期地完成。以追求完美的态度加以扎实的编程功力，那就是你的编程水平。 切记心浮气燥，级别够了，那级别里的东西自然就懂了。悟了就是悟了，没悟也没关系，静下心来，投入时间而已。 一、入门能够解决一些问题的水平。有一定的基础（比如最常见的html标签及其属性、事件、方法；最常见的css属性；基础的javascript编程能力），能够完成一些简单的web前端研发需求。 举个例子：删除一字符串中指定的字符。 12345var str=\"www.baidu.com/?page\";str=str.replace('?page',\"\");alert(str);str=str.substring(0,str.indexof(\"/\"));alert(str); 首先不要苛责代码的对错严谨，毕竟每个程序员都有这样的一个过程；其次，这两段代码在这个实例里没有什么大过错，可能会有瑕疵，但能够解决问题（删除指定的字符），这就是这个级别的特征。 再举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 计算系统当前是星期几var str = \"\";var week = new date().getday();if (week == 0) &#123; str = \"今天是星期日\";&#125; else if (week == 1) &#123; str = \"今天是星期一\";&#125; else if (week == 2) &#123; str = \"今天是星期二\";&#125; else if (week == 3) &#123; str = \"今天是星期三\";&#125; else if (week == 4) &#123; str = \"今天是星期四\";&#125; else if (week == 5) &#123; str = \"今天是星期五\";&#125; else if (week == 6) &#123; str = \"今天是星期六\";&#125;// 或者更好一些var str1 = \"今天是星期\";var week = new date().getday();switch (week) &#123; case 0 : str1 += \"日\"; break; case 1 : str1 += \"一\"; break; case 2 : str1 += \"二\"; break; case 3 : str1 += \"三\"; break; case 4 : str1 += \"四\"; break; case 5 : str1 += \"五\"; break; case 6 : str1 += \"六\"; break;&#125;alert(str);alert(str1); 入门”阶段是每个程序员的必经之路，只要”入门”，你就上路了。所谓”师傅领进门，修行靠个人”，有了这个”入门”的基础，自己就可以摸索着前进了。 进阶之路将javascript、html、css之类的编码帮助手册里的每个方法/属性都通读几遍！只有将基础打好，以后的路才能走的顺畅。参考这些帮助文档，力争写出无瑕疵的代码。 这些编码文档建议不仅是在入门提高期看，在你以后每个阶段破阶的时候都应该看看，最基础的东西往往也是最给力的东西，有时能够给你带来意想不到的收获。 二、登堂能够正确地解决问题。不管你是通过搜索网络，或者通过改造某些成品代码（jquery/dojo/ext/yui）案例，只要能够无错地完成需求。 同样以上面的那段”字符串剪裁”代码为例： 123var str=\"www.baidu.com/?page\";str=str.replace(/?page/,\"\");alert(str); 仅仅解决问题对于”登堂”阶段来说已经不是问题，这个级别所给出方案不能是漏洞百出。以上面这段代码为例：replace方法的第一个参数虽然可以支持字符串，但最佳的类型是正则表达式； 1234var a = new array(\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\");var week = new date().getday();var str = \"今天是星期\"+ a[week];alert(str); 对比”入门级”的代码，不管是从代码量、代码效率、代码优美性、代码思路来说，”登堂”级的这个日期处理代码都要优秀很多。 进阶之路这个阶段虽然能够给出正确的解题方案，但是不一定是最优秀的方案。如何才能得到最优秀的方案呢？首先就是积累各种能够解决需求的方案，然后再验证每个方案，在这些方案中选择最好的一种。因此该阶段的进阶之路就是”行万里路，看万卷书”，积累各个需求的各个解决方案。 你可以扎身在专业论坛（蓝色理想、无忧、csdn）里，通读所有的faq及帖子；你可以打开搜索引擎，穷举所有的搜索结果。自己建立测试环境一一验 证这些代码：去揣摩每段代码的意图，去比较每段代码之间的差异。这两条路可以让你快速完成原始积累，当你再面对大多数需求时能够说这些问题我以前做过，那 你就水到渠成地晋阶了。 三、入室最强代码，知道所有能够解决需求的各种方案，能够选择使用最优秀的方案满足需求。这个级别基本上产品开发编程中的代码主力。给出的一招一式，招招都是绝招。 还以上面的那个例子为例，你能说出1、2、3之间的差别，以及适用于那种环境吗？ 1234567var str=\"www.baidu.com/?page\";// 1、字符串剪裁str.substring(0, str.indexof(\"?page\"));// 2、正则表达式str.replace(/?page/, \"\");// 3、字符串分拆、合并str.split(\"?page\").join(\"\"); 能够解决问题的方法会有很多，但是对于程序员来说应该选择最优秀的。上面这段代码从代码量来说”正则表达式”最优秀；从代码执行效率来说： “字符串剪裁”法最高（chrome中”正则表达式”效率最高），split法最次；从可扩展性上来说，”正则表达式”法最优。具体使用那种方案视具体的 需求环境而定。 “入室”阶段，程序员应该能够肯定的回答：对于这个需求而言，我的代码就是最优秀的代码。 再以”今天是星期几”为例，”登堂”级的代码你敢说是最优秀的代码了吗？ 12// 计算系统当前是星期几var str = \"今天是星期\" + \"日一二三四五六\".charat(new date().getday()); 对比”登堂”级的示例代码，上面这段代码给你什么感受？程序员追求的就是完美。”入室”级别追求的就是每一招每一式的完美无缺。 从web前端编程来说，通过2年左右的努力，很多人能够达到这个水平，但是，很大一部分人的编程能力也就止步于此。或限于产品的需求单一性，或限于需求开发的时间紧迫性，或限于人的惰性，能够完美地解决当前的需求就够了。 由于长期处于技术平台期，技术上得不到提高，通常这个级别的工程师会比较燥。技术上小有所成；或追求个人的突破；或追求产品差异性带来的新鲜感；或者只是想换个心情；因此很多此级别的工程师会经常换公司。 戒骄戒躁： 切勿以为自己能写一手漂亮的代码而自满； 切莫以为别人”尊称”你一声”大侠”你就以 “大侠”自居； 切莫以为自己积累了一些得意的代码就成了框架式开发。 细节决定成败，优秀的方案并不能保证最终的成功。还以”删除指定字符串”为例，原始字符串从格式上来看应该是了个url链接，在去除”pn=0″之 后，最末尾处留了一个尾巴”?”；如果原始字符串是”http://www.xxx.com/?pn=0&amp;a=1″，去除”pn=0″之后 ? 和 &amp; 两个符号紧贴一起，这更是明显的bug。 进阶之路此阶段进阶之路就是：切勿心浮气躁；你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。 再通读几遍html/css/javascript帮助文档。 我建议这个级别的工程师做一做webtreeview控件，要求总节点量一万左右操作流畅，你的晋升之路就在这个控件的编码过程中。 四、入微最强解决方案。你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及前端编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。 123456789101112131415161718192021var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0// 我将这个字符串里所可能想到的各种情况都列举出来var a = [ \"http://www.xxx.com/vmpn=?pn=0\"// pn= 可能出现在 ? 前 , \"http://www.xxx.com/vmpn=?pn=\"// url里允许pn 值为空 , \"http://www.xxx.com/vmpn=?pn=0&amp;a=1\"// url 里可有多个字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0\"// 可能排在最后 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1\"// 可能有多个 pn 字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=2\"// 可能在中间 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1&amp;b=1\" // 可能在中间成组 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=1&amp;pn=1\" // 可能零星分布];/* 需求的不言之秘：? 若出现在字符串最尾则要去之? &amp; 两个符号不可重叠*/var reg = /((\\?)(pn=[^&amp;]*&amp;)+(?!pn=))|(((\\?|&amp;)pn=[^&amp;]*)+$)|(&amp;pn=[^&amp;]*)/g;for (var i = 0; i &lt; a.length; i++) &#123; alert(a + \"\\n\" + a.replace(reg, \"$2\"));&#125; 这个阶段已经不再追求一招一式，对你来说不是使用什么创新绝招解决需求，而是给出成熟稳重的方案，从根上解决问题。针对某个当前需求你的代码可能不是最优，但是针对此类的需求你的代码却是最优秀的代码。 进阶之路很多web前端研发工程师在做了3-4年之后就会进入一个瓶颈期：产品开发需求是小菜一碟，没有新鲜的可以挑战的东西；代码开发中的稀奇的解题方法 都已经尝试过。没有了可挑战的难题，失去了探索的激情，也就没有了再上升的动力，好不容易走过”入室”级别的人又会有八九成止步于此。或转做技术领导人， 或转到其它的领域，或换公司。 这些人的上升之路在哪里呢？ 这个阶段单单依靠技巧和数量的累积已经没有什么效果了，突破之路在第5层《化蝶》里会详细说明，我建议你在这个阶段末尾着重关注编程理论：面向对象/过程、代码组织形式、编译、代码规范、其它的框架设计等等。 我建议这个级别的工程师做一做webeditor控件，不要求完整功能，但是该控件里的模块划分、代码组织、编程思想做到位，给出一个系统的解决方案。 五、化蝶破茧重生，这个层次关注的是编程语言本身，而不再关心产品需求。什么是茧？产品需求就是茧。当你一招胜万招，打遍天下需求之时，你如果还拘泥于需求开发，那就是你限于茧中而不自知。要么就在这个茧里默默地老去，要么就破开茧获得新生。 还是以那个”字符串剪裁”的老例子： 1234567891011121314151617181920212223242526272829/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author:meizz* @version: 2010/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/function escapereg(str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/function delurlquery(url, key) &#123; key = escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0delurlquery(str, \"pn\"); 这段代码相对于层次4《入微》有什么区别吗？从代码实现上来说没有太大的区别，但是从思路上来说却有着本质的区别：1、不再是就事论事，头疼医头，而是把一类问题抽象理论化，一招破万招；2、有封装的概念，不再是每次从零开始，而是站在半山腰开始爬。 在web前端研发队伍里也有很大一部分人《入室》层次时就自我感觉良好，直接跨跃到《化蝶》，积累自己的代码库，抽象化问题。但没有基础，缺少强大 的后劲，即使能够破茧也经受不了风吹雨打。一份不成熟的架构设计对团队开发带来的危害远大于它带来的好处，这种例子在业界屡见不鲜。不要拔苗助长，不要不 会走就想着跑，夯实基础，水到渠成地成长，厚积薄发，强力地破茧而出。 进阶之路你已经从原始积累，到厚积薄发，到破茧而出之后，你所关注的应该不再是一招一式、一个项目、一个模块，而应该是一种思路，一种理论。你可以做以下几 个步骤以突破到更高层次：再仔细看几遍html/css/javascript接口帮助文档；选择一门强语言（c++/c#/java等）观察理解这些语 言的组织结构，语言设计；看看原型链，链式语法编程，泛型，接口编程，dom遥控器等等；仔细阅读成熟的web前端开发框架的设计文档，看他们为什么要这 样设计。 六、大侠这里所说的大侠，不是大家互相吹捧的”大侠”，而是实至名归的高手。这个级别的人完全有能力写出不差于bindows/jquery/ext/yui/dojo的同等级别规模的前端开发框架。应用成熟的开发框架指导、解决问题。 123456789101112131415161718192021222324252627282930313233// 库文件 /mz/string/escapereg.js/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author:meizz* @version: 2010/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/mz.string.escapereg = function (str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125;// 库文件 /mz/url/delquery.js/// include mz.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/mz.url.delquery = function (url, key) &#123; key = mz.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例/// include mz.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0mz.url.delquery(str, \"pn\"); 自成体系，有基础，也有理论高度。知道为什么这样设计，也知道什么样的设计最好。比如这个例子可以有这样的封装： 123456789101112131415161718192021// 库文件 /mz/url/delquery.js/// include mz.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/string.prototype.delquery = function ( key) &#123; key = mz.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return this.replace(reg, \"\\x241\")&#125;// 应用实例/// include mz.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0str.delquery(\"pn\"); 而为什么不采用下面的那种封装呢？经过了《知微》和《化蝶》你就懂了。 进阶之路道法自然，从根上去寻找突破的契机。你可以研读html解析引擎设计与实现，js解析引擎设计与实现，其它语言的代码解析与编译实现等等。 或者出些书。低级别的人写的书要么是一大抄，空无一物；要么是害人。 七、宗师这个级别的人已然到了无招胜有招的境界。项目开发中的难题？没有难题！运行平台的差异？从根本上搞定！代码规范、开发模式，早已经被抛在身后。这个级别的人已经不再关注于某个前端开发框架，而是应对具体的环境给出最佳的理论指导。 这个级别的人所注意的应该是以最合理的系统架构引领着整个团队的进步，在什么样的场景下该用什么样的架构设计。3个、10个、50个、100个人的团队最应该用哪种模式？等你到了宗师级别，你再来回答吧。 进阶之路每一个宗师就是一个高山，就是一个领域里的神，但是你仅满足于在一群比你弱的群体展现你的强大吗？如果还你是止步原地，那总会有人乘着飞机、宇宙飞船从你的头领掠过，高处不胜寒！ 要突破这片领域，那就必须跳出这片领域。要想突破web前端研发的宗师级，那就跳出web前端吧，上面还有web开发。即使你是web前端的宗师， 但没有快速的数据响应，没有高速的网络架构，没有优美的系统支持，你又能如何？所以突破之路就是把目光投到整条web开发的链条中去。 八、飞升其实严格来说，飞升已经不是原领域的范围了。在web研发领域，对于这个层次的有一个很好听的称谓：架构师。当然那些”伪架构师”另当别论。 一法通，万法通。在其它的技术领域，也可以按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级；一样也可以按照我这里所写的每个级别的【进阶之路】来快速提升。 祝贺你再获辉煌！ 看完这篇文章，只能说自己的进步空间还很大，前端路漫漫，一起加油！ 原文链接未找到。再次感谢原文作者！","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"http://xiaoxiaoqd.com/categories/面试宝典/"}],"tags":[{"name":"前端工程师","slug":"前端工程师","permalink":"http://xiaoxiaoqd.com/tags/前端工程师/"}]},{"title":"前端解读：彻底理解css3结构伪类选择器","slug":"css-nth","date":"2017-03-09T05:29:00.000Z","updated":"2017-03-11T02:11:04.318Z","comments":true,"path":"/blog/css-nth/","link":"","permalink":"http://xiaoxiaoqd.com//blog/css-nth/","excerpt":"","text":"css3提供了一整套完备的新选择器。就样式化而言，它允许你匹配更多指定的元素。当你想匹配“列表的最后一项”，或者“总是包含某个东西的第一个段落”，这时你就可以废除那些无意义的id和class了。css选择器有很多，比如属性选择器、后代选择器、否定式选择器、目标伪类选择器、结构伪类选择器等等。今天主要为大家详细讲解css中的结构伪类选择器。 先上全家福: :first-child选择与某个元素同级的第一个元素，且是该元素类型； :last-child选择与某个元素同级的最后一个元素，且是该元素类型； :nth-child()选择与某个元素同级的一个或多个元素，且是该元素类型； :nth-last-child()选择与某个元素同级的一个或多个特定的元素，从这个元素的最后一个同级元素开始算； :only-child选择的元素是它的父元素的唯一一个子元素； :nth-of-type()选择指定的元素； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择父级元素的第一个同类子元素； :last-of-type选择父级元素的最后一个同类子元素； :only-of-type选择一个元素是它的父级元素的唯一一个相同类型的子元素； 是不是快被我绕晕了，好吧，下面对每个进行解析，用图片说话。 :first-child:first-child是用来选择与某个元素同级的第一个元素，且是该元素类型，比如这里有个列表，想让列表中的”1”具有不同的样式，我们就可以使用:first-child来实现：1li:first-child&#123;background:yellow;&#125; :last-child:last-child选择与某个元素同级的最后一个元素，且是该元素类型，与:first-child相对，选择最后一个元素。这里也要同样注意那个问题。例如：1li:last-child&#123;background:yellow;&#125; :nth-child()这是今天的重点，也是最实用的，好好理解一下。:nth-child()选择与某个元素同级的一个或多个元素，且是该元素类型。参数值是an+b，n是计数器，从0开始。a是倍数，b是偏移量。主要有下面几种形式：1234567:nth-child(num); /*选择第num个元素*/:nth-child(n);/*参数是n,n从0开始计算*/:nth-child(n*num)/*n的倍数选择，n从0开始算*/:nth-child(n+num);/*选择大于num后面的元素*/:nth-child(-n+num)/*选择小于num前面的元素*/:nth-child(n*num+1);/*表示隔几选一*///上面num为整数 :nth-last-child():nth-last-child()与:nth-child()用法一样，唯一的区别就是一个从前面数，一个从后面数。这里就不赘述了。 :only-child:only-child选择的元素是它的父元素的唯一一个子元素;也就是该元素不能有其他的同级元素。与:only-of-type的区别是，：only-of-type选择的元素可以存在同级元素，但该元素类型只能存在一个。 :nth-of-type()，:nth-last-of-type()，:first-of-type，:last-of-type和:only-of-type我之所以这样写是我不想再重复讲述，如果分类的话，前五个可分为一组（简称为child组），后五个分为一组（简称为type组），用法一对一都是一样的，只是有一个重要的不同点。 child组计数时的第几个都是从该元素的第一个同级元素开始，如果第几个与该元素类型一样则生效。而type组计数时的第几个都是从与该元素类型一样的同级元素的第一个开始，不受其他同级元素的干扰。这是重中之重，好好理解一下，可以写几个例子感受一下。 结构伪类选择器不兼容IE8及更早版本，所以对浏览器兼容性比较强的小伙伴们还是不要选择这些方法，老老实实定义id或class吧。如果要求不高，这些方法在选取标签添加样式上还是很给力的，快去尝试一下吧。 竹风原创，欢迎交流学习。转载请附上本文链接，谢谢！","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://xiaoxiaoqd.com/categories/前端基础/"},{"name":"CSS","slug":"前端基础/CSS","permalink":"http://xiaoxiaoqd.com/categories/前端基础/CSS/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://xiaoxiaoqd.com/tags/css3/"}]},{"title":"涨姿势：你真的会用console调试代码吗？","slug":"js-console","date":"2017-03-08T05:22:00.000Z","updated":"2017-03-11T02:11:59.260Z","comments":true,"path":"/blog/js-console/","link":"","permalink":"http://xiaoxiaoqd.com//blog/js-console/","excerpt":"","text":"如果你是开发测试人员，一定对console不陌生。如果是初学者，恐怕只知道console.log()啦。对于整个的console家族，你又了解多少呢？我们使用console对js进行调试，但js原生中默认是没有console对象的，它是宿主对象，也就是浏览器提供的内置对象，所以浏览器不同，console对象也会有些许差异。使用console.log(console)打印出浏览器中的console对象，看看你用过哪些？ 下面是chrome浏览器截图： 仔细看一下，还真的不少呢。接下来介绍几个常用的console方法。 用来打印消息 打印字符串：console.log() 打印提示消息：console.info() 打印警告消息：console.warn() 打印错误消息：console.error() 打印调试信息：console.debug() 这几个方法都可以接受多个参数，逗号分隔。它会在每次输出结尾添加换行符。没有返回值就返回undefined。另外这五种方法都可以使用printf风格占位符，字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种。如果第一个参数是格式字符串，方法会将依次用后面的参数替换占位符，然后再进行输出。五种方法示例如下： 统计次数console.count()有时候我们需要统计一个函数被调用了几次，一般都是加入一个变量然后输出。现在，我们可以直接使用console.count()来帮助我们统计并输出。 判断真假console.assert()我们写代码的时候总会碰到判断某个变量是否为真，这个时候可以console.assert()来判断，当表达式为false的时候，输出信息到控制台。 查看对象信息console.dir()如果想要看详细的对象信息，我们可以使用 console.dir，将一个 JavaScript 对象的所有属性和属性值显示成一个可交互的列表，它还能打印出函数等。 打印成表格console.table()可以将传入的对象或数组这些复合数据以表格的形式输出。 输出信息分组console.group()和console.groupEnd()如果输出信息比较多，可以进行分组管理。 console方法还有很多，这里就不一一列举了，想了解更多请自行查阅官方API文档。掌握这些方法，对我们调试代码很有帮助。 原文链接：http://www.wangzc.cc/points-console/","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://xiaoxiaoqd.com/categories/前端基础/"},{"name":"Javascript","slug":"前端基础/Javascript","permalink":"http://xiaoxiaoqd.com/categories/前端基础/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://xiaoxiaoqd.com/tags/js/"},{"name":"console","slug":"console","permalink":"http://xiaoxiaoqd.com/tags/console/"}]}]}