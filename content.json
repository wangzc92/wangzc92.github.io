{"meta":{"title":"笑笑前端圈","subtitle":"纯净前端知识分享平台","description":null,"author":"Xiaoxiao","url":"http://xiaoxiaoqdq.com"},"pages":[{"title":"About us","date":"2017-03-10T05:26:24.000Z","updated":"2017-03-11T15:51:55.732Z","comments":true,"path":"about/index.html","permalink":"http://xiaoxiaoqdq.com/about/index.html","excerpt":"","text":"笑笑前端圈是一群志同道合而又富有激情的前端爱好者（也就是笑笑团队）创建的纯净，高质量的前端交流学习平台。 既然选择了远方，便只顾风雨兼程！"}],"posts":[{"title":"掌握 HTTP 缓存——从请求到响应过程的一切","slug":"se-http-cdn","date":"2017-03-11T15:32:00.000Z","updated":"2017-03-11T15:36:26.685Z","comments":true,"path":"/blog/se-http-cdn/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/se-http-cdn/","excerpt":"","text":"CDN类的网站曾经一度雄踞 Alexa 域名排行的前 100。以前一些小网站不需要使用 CDN 或者根本负担不起其价格，不过这一现象近几年发生了很大的变化，CDN 市场上出现了很多按次付费，非公司性的提供商，这使得 CDN 变成人人都能负担的起的一种服务了。本文讲述的就是如何使用这种简单易用的缓存服务。 使用内容分发网络（ CDN ）你需要先正确地认识 HTTP 响应头：和 HTTP 响应头中的哪些标签相关？它们是怎么起作用的？如何使用它们？文章中我会回答这些问题。 本文讲的并不会像教科书那么精确，实际上在某些情况下，为了叙述的清晰、简洁，我会按自己的理解简化某些问题，文章中会通过一些实际的例子来介绍缓存理论。在这篇文章的基础上，还会写一些文章来介绍对于某些指定的 CMS 或框架如何使用 CDN 来作为缓存层。 为什么使用 CDN？CDN 是一个全球分布式网络，它把网站内容更快地传递给全球范围内的一个具体位置，而往往这个具体的位置离实际的内容服务器距离很远。举个例子，你的网站主机在爱尔兰，而你的用户则在澳大利亚访问。这时当你的用户访问你的网站的时候，延迟会很大，把你的（静态）数据用 CDN 放到澳大利亚则会很大程度上提高用户访问网站的体验。 然而 CDN 的使用并不局限于此。其实 CDN 可以理解成一个普通缓存，如代理缓存（边缘缓存）。即便你并不关心用户的具体地理位置，你也应该考虑使用 CDN 的代理缓存来提高你的用户体验。 为什么使用代理缓存？简而言之，代理缓存会缓存你网站一些页面，通过缓存来传输“静态”内容非常快。一个简单的例子，假设你有一个带有开始页面的博客，这里面列出了所有近期的博客列表。完成这一过程，PHP 脚本要从数据库中获取到最近的文章实体，并且将它们转换成 HTML 结果页并返回给用户。因此，对于一次请求（访问）包含了：一次 PHP 执行 + 一组数据库查询。对于 1000 次请求（访问）包含了：1000 次 PHP 执行 + 1000 组数据库查询。每一次 PHP 执行都要进行 CPU、内存和 I/O 操作，对于数据库操作也是同样。 请求的需求量和访问用户的多少呈线性正比关系。听起来怎么样？不怎么样，因为这个线性关系是有最大限度的：磁盘最大只能提供一定程度的 I/O，CPU 和内存也都不是无限的。这样下去到了某个点，也就是说某个资源到了瓶颈的时候，就出现问题了：你的网站会访问的非常慢，甚至会出现所有人都不能访问的情况。其实这时其他资源并没有被全部打满。诚然，这时你可以扩展你的硬件规模来突破这一瓶颈，但是这将使工程变得很复杂，成本也更高。实际上还有更简单、更便宜的解决方法。 在中间加一层代理缓存，会减少资源对你的限制。拿前面的例子来讲，使用代理缓存只有第一次请求需要执行 PHP 脚本、查询数据库和生成 HTML 结果页。所有后面过来的请求都会从这个缓存中取内容，读取缓存几乎和直接读取内存一样快。这意味着，上面的线性规模瓶颈的问题解决了！100 个用户或者1000 个用户都没关系，依然只有 1 次 PHP 执行、1 次数据库查询和 1 次的结果页生成。 CDN != CDNCDN 的类型也各有不同。网站管理者可能会好奇数据是怎么存储的？存放在哪？以及数据是如何分布在 CDN 上的？是如何分发的呢？本文不是写给网站管理者的而是写给开发者的，所以在这我只能告诉你有“经典 CDN”和“对等 CDN”，后者是现在主流采用的方法。 对于开发者，相比于把数据拿到 CDN 以后做什么来说，会对如何把数据放到 CDN 中更感兴趣。说起来，有 push CDN 和 pull CDN 两种。顾名思义，“push CDN” 表示你要给 CDN 提供内容；“pull CDN” 表示如何从 CDN 取内容。 本文将主要介绍 pull CDN，因为在很多情况下 pull CDN 更加简单易用，不需要费多大事就能集成到现有的网站中。 pull CDN 是如何起作用的？我们来做个例子，假设你有一个可访问的网站，URL 是 https://www.foobar.tld。在这样的场景下，域名 www.foobar.tld 会被放到 pull CDN 服务器中，而不是你的网站服务器中。CDN 作为你网站服务器的一个代理。 还有一个不被公开的域名指向实际的网站服务器。在这个例子中假设它是 direct.foobar.tld，实际网站服务器叫做源。 这个 CDN 将会接受所有的请求。如果它的缓存中有结果的话将会直接返回给用户，否则会将这个请求托管给你实际的网站服务器，然后把返回的结果缓存起来为以后的请求做储备，同时将结果返回给用户。 最简单的 pull CDN 运行的过程如下： 获取一个页面的请求，这个页面：http://www.foobar.tld/some/page 把 some/page 当做缓存 key 检查缓存中是否存在 在缓存中则直接从缓存中返回结果给用户 不在缓存则请求 http://direct.foobar.tld/some/page，把返回的结果以 some/page 作为 key 写入缓存，并返回结果给用户 静态内容 VS 动态内容上面的这一过程对于完全静态的内容完全适用。静态内容指的是如果用户访问同一个 URL 地址，返回的所有数据都是一样的。比如 CSS 文件就有这样的特点，http://www.foobar.tld/public/css/main.css 这个文件是一个普通文件，对于所有访问网站的用户都是一样的，那么它就特别适合用缓存存起来。 和静态文件相对的是动态文件。内容在运行时才能确定，这种情况也是非常常见的。比如多语言问题，需要根据浏览器语言来返回内容。还有一些和 “user session” 相关的内容，比如当用户登陆了以后，就要把“登陆”按钮换成“退出”按钮，你肯定不希望这个被缓存。这些高度活跃的内容（如每小时或者更短时间更新的页面）不能被缓存，或者说不能在缓存中停留时间过长。 这就是缓存有意思的地方，理解和实现它并不难。 缓存头绝大多数的 pull CDN 采用以“每页”缓存形式解决动态内容的问题。为了达到这样的效果，一个简单的方法是 HTPP 响应缓存头。 首先对于缓存头你需要知道有“旧版本”和“新版本”两种，就是说它并不是一开始就设计成当前所使用的这个版本的，也有一个逐渐演变的过程。新版本指的是 HTTP/1.1，而旧版本指的是 HTTP/1.0。它有特别多的可选选项，每个人对这个问题都很头疼。我认为这是大家不愿意使用缓存头的最重要的原因。 言归正传，我们只关注 ETag 和 Cache-Control 这两个标签就足以了。大多数 CDN 还支持旧版本（Expires，Pragma 和 Age），不过这些只作为向后兼容来使用。 ETag 头我们从最简单的开始 ETag：它是文档版本的标识符。通常是内容的 MD5 值，不过它也可以包含其他内容，代表的是文档的版本/日期，如： 1.0 或者 2017-02-27。这里注意一点是，它必须用双引号括起来，如：ETag: &quot;d3b07384d113edec49eaa6238ad5ff00&quot;。 二次验证现在来考虑 ETag 的实际应用：二次验证。我们暂时不考虑前面代理+源的架构模式，只考虑简单的客户端-服务器模式。如下图： 假设客户端请求了 http://www.foobar.tld/hello.txt，接着服务端返回了如下的响应内容：12345678910111213141516 # REQUEST GET /hello.txt HTTP/1.1 Host: www.foobar.tld # RESPONSE HTTP/1.1 200 OK Date: Sun, 05 Feb 2017 12:34:56 UTC Server: Apache Last-Modified: Sun, 05 Feb 2017 10:34:56 UTC ETag: &quot;8a75d48aaf3e72648a4e3747b713d730&quot; Content-Length: 8 Content-Type: text/plain; charset=UTF-8``` `the body`在响应里面，有两个有意思的头标识：一个是 `ETag`，内容的 MD5值，一个是 `Last-Modified`，这是 `hello.txt` 文件最后一次被修改的时间。这里就是二次验证起作用的地方：当客户端在很短的时间内再次访问上面的 URL，客户端浏览器会使用 `If-*` 请求头。如 `If-None-Match` 检查 `ETag` 的内容是否有改变。也就是说，如果 `ETag` 发生变化，客户端接收到的一个完整的新响应；如果 `ETag` 没变化，客户端接收到的是一个表明内容没变化的标识。 GET /hello.txt HTTP/1.1 If-None-Match: &quot;8a75d48aaf3e72648a4e3747b713d730&quot; Host: www.foobar.tld 123456789如果 `ETag` 没有改变，那么服务端将会返回：``` HTTP/1.1 304 Not Modified Date: Sun, 05 Feb 2017 12:34:57 UTC Server: Apache Last-Modified: Sun, 05 Feb 2017 10:34:56 UTC ETag: &quot;8a75d48aaf3e72648a4e3747b713d730&quot; Content-Length: 8 Content-Type: text/plain; charset=UTF-8 正如上面所展示的，这次服务器的响应里面不是 200 ok，而是304 Not Modified，这就是说它略过包体部分，让客户端直接去自己的缓存里拿数据。在这个例子中，包体内容是 the body，比较小，效果不明显。可是想象一下如果是很大的内容呢，或者是很复杂的动态生成内容呢，价值就很大了。 作为一个开发者，你可能会想：“并没有那么好用嘛，我还不得不掌握 IF- 类的头标识，比以前更费事了”。 别急，这只是介绍了共享缓存，也就是代理缓存的由来，我们看原始的架构：&lt;客户端-代理-源端&gt;，代理根据自己的缓存返回给客户端 304 Not Modified，接下来的章节详解介绍，介绍之前我要先讲一下 Last-Modfied 头。 在处理上面那个 hello.txt 静态文件的例子时，客户端还可以使用 If-Not-Modified-Since: Sun, 05 Feb 2017 10:34:56 UTC 来达到同样的效果（返回 304 响应）。这对于静态文件来说也很好用，因为响应头中的 Last-Modified 标识是根据服务器磁盘上的“更改时间戳”自动生成的。然而，“更改时间戳”对于动态文件通常没什么用，因为动态生成文件频繁更新，时间戳很难确定。我们都知道，你最想缓存起来的是内容，生成内容的代价是最大的，所以 ETag 头是更好的选择。 Cache-Control头Cache-Control 头相对来讲难一些。两个原因：第一，Cache-Control 既可以用于请求头，也可以用于响应头。本文中着重讨论响应头，因为这是开发者所必须要掌握的。第二，它控制着两个缓存：本地缓存（又称私有缓存）和共享缓存。 本地缓存，是指在客户端本地机器中的缓存。站在开发者的角度，它并不完全受你的控制，通常浏览器会自己决定是否把某些内容放到缓存中，这意味着：不要依赖于本地缓存。用户也可能在关闭浏览器的时候清理所有缓存，而你并不知道有这样的操作。除非你监测到了某个用户的流量不断上涨，导致缓存内容迅速失效，这时候你才会意识到。 共享缓存，也就是本文所介绍的：处于客户端和服务器之间的缓存。即 CDN。你对共享缓存拥有绝对的控制，应该好好地利用它。 现在我们来用一些代码作为示例深入学习一下。 Cache-Control: public max-age=3600 Cache-Control: private immutable Cache-Control: no-cache Cache-Control: public max-age=3600 s-maxage=7200 Cache-Control: public max-age=3600 proxy-revalidate 乍一看这些代码很令人困惑，但是不要担心，它并没有那么难，我来一点点介绍。首先你要知道 Cache-Control 有三种属性：缓冲能力、过期时间和二次验证。 首先是缓冲能力，它关注的是缓存到什么地方，和是否应该被缓存。他的几个重要的属性是： private：表示它只应该存在本地缓存； public：表示它既可以存在共享缓存，也可以被存在本地缓存； no-cache：表示不论是本地缓存还是共享缓存，在使用它以前必须用缓存里的值来重新验证； no-store：表示不允许被缓存。 第二个是过期时间，很显然它关注的是内容可以被缓存多久。它的几个重要的属性是： max-age=&lt;seconds&gt;：设置缓存时间，设置单位为秒。本地缓存和共享缓存都可以； s-maxage=&lt;seconds&gt;：覆盖 max-age 属性。只在共享缓存中起作用。 最后一个是二次验证，表示精细控制。它的几个重要属性是： immutable：表示文档是不能更改的。 must-revalidate：表示客户端（浏览器）必须检查代理服务器上是否存在，即使它已经本地缓存了也要检查。 proxy-revalidata：表示共享缓存（CDN）必须要检查源是否存在，即使已经有缓存。 通过上面的具体解释，现在再来描述上面 Cache-Control 的那段代码所表达的意思就好理解多了： 本地缓存和 CDN 缓存均缓存 1 小时； 不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新； 不能缓存。如果一定要缓存的话，确保对其进行了二次验证； 本地缓存 1 小时，CDN 上缓存 2 小时； 本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源中文档是否已经被改变。 实例理论会很单调乏味，现在用短的实例来演示如何自动注入 ETag 和 Cache-Control 头。例子是一个 Apache 的 .htaccess 文件，但是我希望你能够领会要领，并且根据你自己的实际情况，应用到你自己的 Web 应用中。123456789101112# 为所有图片设置 ETag，以及缓存时间为 1 天&lt;FilesMatch &quot;\\.(gif|flv|jpg|jpeg|png|gif|swf)$&quot;&gt; FileETag -INode MTime Size Header set Cache-Control &quot;max-age=86400 public&quot;&lt;/FilesMatch&gt;# 为所有的 CSS 文件、JS 文件设置 ETag，以及缓存时间为 2 小时，同时保证进行了二次验证&lt;FilesMatch &quot;\\.(js|css)$&quot;&gt; FileETag -INode MTime Size Header set Cache-Control &quot;max-age=7200 public must-revalidate&quot; Header unset Last-Modified&lt;/FilesMatch&gt; 上面例子，是一个对 URL：http://www.foobar.tld/baz.jpg 的响应。包含了一个 ETag 头，由更改时间和文件大小所构成，还有 Cache-Control 头来设定缓存 1 天的时间。123456789101112# REQUESTGET /baz.jpg HTTP/1.1Host: www.foobar.tld# RESPONSEHTTP/1.1 200 OKDate: Tue, 07 Feb 2017 15:01:20 GMTLast-Modified: Tue, 07 Feb 2017 15:01:15 GMTETag: &quot;4-547f20501b9e9&quot;Content-Length: 123Cache-Control: max-age=86400 publicContent-Type: image/jpeg 对于 URL： http://www.foobar.tld/dist/css/styles.css 的响应同样也包含了 ETag 头。由更改时间、文件大小和限定了 2 小时的 Cache-Control 构成。Last-Modfied 头也删除掉以确保只有 ETag 用来做二次验证。123456789101112# REQUESTGET /styles.css HTTP/1.1Host: www.foobar.tld# RESPONSEHTTP/1.1 200 OKDate: Tue, 07 Feb 2017 15:00:00 GMTServer: ApacheETag: &quot;20-547f1fbe02409&quot;Content-Length: 32Cache-Control: max-age=7200 public must-revalidateContent-Type: text/css Cookies你已经知道了缓存头是如何起作用的，现在我们来看下在缓存里面 cookie 起了什么作用。首先， Cookie 的设定也在 HTTP 响应头中，名字是 Set-Cookie。设置一个 cookie 的目的是标识这个用户，就是说你需要为每个用户设置一个 cookie。 想象一下缓存的场景，你是否会缓存一个包含了 Set-Cookie的 HTTP 响应，在缓存时间内，每个人都会得到相同的 cookie 和同样的用户 session？你肯定不想这样。 另外，用户 session 状态的改变可能会影响到响应内容的变化。一个简单的场景：电商购物车。你给用户要么提供一个空购物车，要么是用户自己选了很多物品的购物车。同样的道理，你不希望这个也被缓存，毕竟每个用户都应该有自己的购物车。 一个解决方法是在运行时通过 JavaScript 设置 Cookie，比如 Google Analytics。GA 通过 JS 设置 cookie，但这个 cookie 既不影响渲染，也不设置 Set-Cookie 头。GA 会在目标网站上添加类似于 “you are tracked via Google Analytics” 的图标，但是只要这些改变都是在运行时添加进去的，就都没有问题。 正确处理 cookie 和缓存首先你需要知道你网站的 cookie 的工作原理。cookie 是不是只在特定时间使用（如在用户登录过程中使用）？原则上，cookie 是不是会被注入到所有响应？ 正如上一节所说的，不论何时服务器返回了一个带有 Set-Cookie 的响应，你都希望能够保证它不会被缓存。那么问题就转化成为，当你返回一个带有“用户特性”内容的响应时（如购物车），CDN /代理服务器，会作何操作？ 如果没设置 Set-Cookie，是不是允许缓存呢？ 如果设置了 Set-Cookie，是不是自动丢弃所有 Cache-Control 头呢？ 其实，如果从应用层面来讲，你尽管可以去实现你所喜欢的 web 应用就可以了，至于 cookie 和 CDN 都是自动设置的。还是用 Apache 的 .htaccess 来作为例子来解释：12345678# 1) 如果 cookie 没设置，允许缓存Header set Cache-Control &quot;public max-age=3600&quot; &quot;expr=-z resp(&apos;Set-Cookie&apos;)# 2) 如果 cookie 被设置，不允许缓存Header always remove Cache-Control &quot;expr=-n resp(&apos;Set-Cookie&apos;)# 2a) 第二条的另一种形式，如果设置了 cookie，缓存时间设置成0Header set Cache-Control &quot;no-cache max-age=0 must-revalidate&quot; &quot;expr=-n resp(&apos;Set-Cookie&apos;) 规则1：如果没设置 Set-Cookie，则给 Cache-Control 设置一个默认值； 规则2：如果设置了 Set-Cookie，则忽略 Cache-Control； 规则2a：是规则2的另一种表示形式，设置最大缓存时间是 0。 不设置 cookie 的访问路径一些 CMS /框架还在使用一种暴力的方式种 cookie。而实际上，决定是否种 cookie 取决于不同的因素，比如会话时间因素。如果你有一个很高安全性的 web 应用，设置会话时间是 5 分钟，那么为每个响应设置一个新 cookie 都不过分。而假设你的应用连“用户特性”都没有，也就是说所有的东西对所有用户都是公用的，那么设置任何形式的 cookie 都是没有道理的。 所以下面这个例子是否适合你自己，很大程度上依赖于你的应用到底是什么类型的。我们来一起看一下，我先给一下这个例子的上下文关系：假设你有个新网站，你的所有文章都在 http://www.foobar.tld/news/item/ 这个路径下面。现在你希望能够保证，所有访问 /news/item/&lt;ID&gt; 的路径都不包含 Set-Cookie，因为你确定不需要 cookie。12345678910# 通用 PHP 重定向做法，将&quot;?path=$1&quot;写到重定向规则里RewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.php?path=$1 [NC,L,QSA]RewriteRule ^$ index.php [NC,L,QSA]# 利用 query 中的 path= 来判断&lt;If &quot;%&#123;QUERY_STRING&#125; =~ m#path=news/item/[^&amp;]+#&quot;&gt; Header always unset Set-Cookie&lt;/If&gt; 通过这样的设置，你就可以保证所有访问 /news/item/&lt;ID&gt; 的路径都不包含 Set-Cookie。而到底是否应该设置 cookie，需要你根据你自己的应用特点来判断。 设计出来的缓存能力有很多设计方案可以使你的 web 应用具有高缓存性。鉴于本文仅仅是一篇文章而不是一本书，我不可能每个点都深入的来讲，但是我可以着重提一下通用的方法。 我还用电商作为例子。假设电商网站首页的 top 位置上展示了正在出售的物品，生成这些物品需要进行若干次的数据库操作，代价比较大，因此希望把它们缓存起来。但是，问题在于购物车，它是为那些登陆用户准备的，所以希望得到的结果是： top 物品是一样的，而针对登陆用户展示购物车。 那么优化策略首先要为每个用户提供一个和登陆状态无关的“通用”页。然后通过 JavaScript 为已经生成的网页提供购物车。站在用户的视角，最终展示形式是一样的。那么现在你有了两个请求（整个网页请求 + 购物车请求），而不是一个请求（整个网页请求，包含购物车）。ok，现在你可以把代价很大的部分，即 top 物品分离出来，把它们缓存起来了。 这种方法或者其延伸方法，不适合已经开发好的项目。因为它可能会改变很多接口和视图层（MVC 架构）的内容。最好你在一开始就设计好。 缓存失效：busting 和 purging使用 max-age 和 s-maxage 你已经可以很好地控制一个指定的响应被缓存多长时间。但是这不足以适用于所有的情况。这些设置都是在返回响应时预设的，而现实情况往往是并不知道一个响应应该设置多久期满。回想一下刚才电商首页的例子：假设它包含了展示在 top 位置的 10 个实体。你设置了 max-age=900给这个首页以保证每15分钟刷新一次。现在，其中 1 个实体由于发布了太久了要被撤销，那么你就需要把之前的缓存响应删掉，这时候其实还没到 15 分钟，那么该怎么办？ 不要担心，这是一个常见的问题，有很多方法解决。首先我们先来解释一下术语： 缓存 busting，是用来解决浏览器长期缓存问题，它通过版本标识来告诉浏览器该文件有一个新的版本。这时浏览器将不会从本地缓存取内容，而从源服务器请求新版本的文件。 缓存 purging，表示直接从缓存中删除内容（即响应），以使得缓存可以立马得到更新。 用于版本管理的缓存 busting这种方法经常使用在 CSS 文件、JS 文件上。通常一个确切的版本号、一串哈希或者时间戳都可以用作标识，如下面的例子： 数字版本号：style-v1.css，style.css?v=1 哈希串版本：style.css?d3b07384d113edec49eaa6238ad5ff00 时间戳版本：styles.css?t=1486398121 这时候在发布程序的时候，你只要注意文件的版本就可以了。举个例子，一个 HTML 网页通过 &lt;link rel=&quot;stylesheet&quot; href=&quot;..&quot;&gt; 这种形式包含了一个 CSS 文件。CSS 文件将会被缓存起来，这时如果你想让你的新 CSS 文件起作用，那么用最新的版本号命名它就可以。如果不做任何变化的话，即便你更新了文件，这个 HTML 还会使用缓存中的旧 CSS 文件。 缓存 purging不同 CDN 供应商清除缓存的方式不一样。很多供应商都是基于开源软件 Varnish 来构建自己的 CDN 服务，所以一个通用的做法是在 HTPP 请求中使用 PURGE 结构，如：12PURGE /news/item/i-am-obsolete HTTP/1.1Host: www.foobar.tld 使用这个请求通常需要权限认证，或者是源确认（即 IP 白名单），不过不同供应商的要求也不一样。 清除一个或几个缓存项比较容易，但是在某些场景下，却不是这么简单。举个例子，一个博客的场景，博客里面都有关于作者的部分，现在你要改变关于作者的一些内容，那么你需要手动清理所有包含了作者信息的页面。你确实可以一个一个手动清理，但是假设你有成千上万个网页被影响了，那问题就变得麻烦了。 下面介绍一个解决方案。 代理标签“代理标签” 这个名字来源于 CDN 供应商 Fastly，不同供应商给它起的名字不一样，比如还有叫它“缓存标签”的，Varnish 叫它 Hashtwo/Xkey，这里我就不详细介绍其他供应商的情况了。 不论它叫什么，它们的目的都是一样的：给响应打标签。这样你就可以轻松地从缓存中删除相关的标签就可以，甚至都不用知道缓存的到底是什么东西。 还是拿&lt;客户端-代理-源端&gt;来举例子，源端返回一个含有代理标签的响应：1234HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 123Surrogate-Key: top-10 company-acme category-foodstuff 这个例子中的标签为：top-10， company-acme，和 category-foodstuff。这里给一个电商的实际场景来理解其含义：这个响应包含了电商首页的前 10 个物品，这些物品由 ACME 公司提供，并且其目录类别都设定为食品类。 设置了标签以后，当物品发生了变化以后，你只需要删除包含有 company-acme 和 top-10 的标签就可以了。是不是很简单？ 同样，具体如何清除缓存的操作方法，不同 CDN 供应商是不一样的。 写在最后上面讨论的更多的是理论上的做法，还有很多文章专门介绍不同的 CDN 的使用。如果你想深入了解的话，下面的资料每篇可能都是你需要的。 谷歌开发者：HTTP 缓存 Push CDN 和 Pull CDN CDN 类型（管理员视角） 缓存头概览 缓存详解（Mozilla） ETag头详解（Mozilla） Cace-Control 头详解（Mozilla） If-None-Match 头详解（Mozilla） Fastly：代理标签 KeyCDN：缓存标签","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Service","slug":"前端笔记/Service","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Service/"}],"tags":[{"name":"http","slug":"http","permalink":"http://xiaoxiaoqdq.com/tags/http/"},{"name":"CDN","slug":"CDN","permalink":"http://xiaoxiaoqdq.com/tags/CDN/"}]},{"title":"通过动图形象地为你介绍 Flexbox 是如何工作的（二）","slug":"cs-flexbox-works-2","date":"2017-03-11T15:18:00.000Z","updated":"2017-03-11T15:37:33.038Z","comments":true,"path":"/blog/cs-flexbox-works-2/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/cs-flexbox-works-2/","excerpt":"","text":"在上一篇文章中，我们介绍了 flexbox 的几个属性： flex-direction，justify-content，align-items 和 align-self。 这些命令在创建基本布局上是特别有用的。而一旦你开始用 flexbox 创建网站的时候，你需要对其进行深挖以最大化地发挥它的价值。 现在我们来深入学习一下 flexbox，并且告诉你如何利用它来构建一个漂亮的布局。 属性1：flex-basis上一篇文章中，主要介绍了应用在容器元素上的属性。这次我们专门介绍关于子元素的使用。 以我之见，我们要介绍的第一个属性，是 flexbox 教程里面解释的最少的属性之一。 但是不要担心，其实它很简单。 flex-basis 控制的是一个元素的默认尺寸，但是它可以被 flexbox 的其他属性所影响（稍后会详细介绍）。 下面这个 GIF 表示的是它和 width 这个属性是可以互换的。 然而，flex-basis 和 width 唯一不同的地方是，它是和 flex 坐标轴保持一致的。 flex-basis 是在主轴方向上影响元素大小的。 我们来看一下，当我们保持 flex-basis 不变的情况下，改变主轴方向，会发生什么。 这里要注意，原来设置的是 height 属性，现在必须要手动地设置为设置 width 属性。因此可以看到，flex-basis 依赖于 flex-direction 来影响 width 或者 height。 属性2：flex grow让我们继续学习，增加点复杂度。 首先，我们把所有的形状 width 都设置为120px： 现在我们来引出一个属性 flex-grow，它的默认值是 0。也就是说所有的形状没有被允许自动地填充整个容器。 这又是什么意思呢？让我们来看看，如果把各个形状的 flex-grow 设置成 1 会发生什么： 所有形状一起充满了整个容器的宽度，并且他们之间的间隙也都是相同的。也就是说 flex-grow 覆盖了 width。 那么令人疑惑的问题又来了，它的值具体表达什么意思呢？flex-grow: 1 意味着什么呢？ 为了解释这个问题，我们把每个形状的 flex-grow 值设置成 999，看一下效果： 可以看到，并没有变化。 这是因为：flex-grow 并不是一个绝对值，而是一个相对值。 对于每个元素来说，重要的不是 flex-grow 的值是多大，而是本元素的这个值和其他元素的这个值相比较，相对大小是怎么样的。 如果我们设置每个元素的 flex-grow: 1，而改变第三个形状的 flex-grow，我们可以看到下图的改变： 为了完全理解这个知识点，我们来快速地做一些简单的数学运算。 每个元素 flex-grow 的起始值都是 1。把所有元素的该值加起来，总和是 6。因此容器的总宽度被分成了 6 份。每个形状就被扩展到容器所有可用空间的 1/6。 然后设置第三个形状的 flex-grow 值为 2。那么容器的宽度被分成 7 等份，因为所有 flex-grow 属性是：1 + 1 + 2 + 1 + 1 + 1。 第三个形状占了整个容器空间的 2/7，其他的占了 1/7。 同理，当设置第三个形状的 flex-grow: 3 的时候，整个容器宽度被分成了 8 份（1 + 1 + 3 + 1 + 1 + 1），第三个形状占了 3/8,其他的占了 1/8。 以此类推。 flex-grow 只和比例相关，例如，设置第三个形状 flex-grow: 12，其余每个形状的 flex-grow: 4，可以和第三个设置成 3，其他的设置成 1得到同样的效果，见下图： 重点在于，每个形状的 flex-grow 和其他形状的是成比例的。 最后要提醒的是，要记住 flex-grow 和 flex-basis 类似，它也是应用在主轴上的。形状都会做宽度的改变，除非我们设置 flex-direction 为列。 属性3：flex shrinkflex-shrink 刚好和 flex-grow 相反，它是决定形状收缩多少的。 它只应用于元素必须要缩小以适应容器的情况，即容器太小了。 他的主要用法是指定哪个元素你想要缩小，哪个不想缩小。默认情况是每个形状都 flex-shrink: 1，这表示每个形状都会随着容器的缩小而缩小。 我们来在应用中看一下，在下面的 GIF 图中，每个形状的 flex-grow 都是 1，所以他们填满了整个容器。每个形状的 flex-shrink 也都是 1，所以它们也会像下面图中这样收缩。 那么现在，我们来设置第三个形状的 flex-shrink 值为 0。不允许它收缩，所以当它拉伸的时候，会随着容器拉伸，而当收缩的时候，不允许比他的 width 还小，即不允许比 120px 还小。 默认值是 1，表示元素默认允许收缩，除非你指定它为不允许。 同样，flex-shrink 是和比例相关的。如果设置一个形状的 flex-shrink 为 6,而其他的是 2，那么这个形状随着容器空间的压缩，将以 3 倍于其他形状的速度缩小。 这里尤其注意：是空间收缩的速度是 3 倍，而不是说他的宽度会缩小到原来的 1/3。 接下来我们要深入了解元素到底收缩或者拉伸了多少，不过首先，我们先回到上一个属性，把所有的知识串起来。 属性4：flexflex 是 grow，shrink 和 basis 的简化形式——把他们所有都放到了一起。 它的默认值是：0（grow），1（shrink）和 auto（basis）。 在我们的上一个例子中，我们用它来简化两个形状，下面是它们的属性：123456.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 两个有着相同的 flex-basis。也就是说如果有足够的空间（容器的空间等于 600px 加上边缘和内边距），他们每个的宽度将是 300px。 但是随着容器的拉伸，形状 1 （有更大的 flex-grow 值）将会以两倍的速度增长。随着容器的收缩，形状 2 （有更大的 flex-shrink 值）将会以两倍的速度压缩。 都放到一起展示，如下图： 元素是怎样收缩和拉伸的呢这里有个问题可能会使人疑惑：当形状 1 拉伸时，并没有拉伸到形状 2 的两倍大小。同样，当形状 2 缩小时，也并没有缩小到形状 1 的一半，尽管 flex-shrink 的比值是 2:1。 实际上它的意思，并不是说他们的大小是 2:1 或者 1:2，而是说它们的收缩率或拉伸率。 简单计算容器的初始大小是 640px。在除去容器要预留的 20px 的间距后，剩下的空间足够将两个形状恢复到 flex-basis 等于 300px。 当容器设置到了 430px 时，空间减小了 210px。形状 1，设置了 flex-shrink 是 1，减小了 70px。而形状 2，设置了 flex-shrink 是 2，减小了 140px。 当容器减小到 340px，容器空间减小了 300px。这是形状 1 减小 100px，而形状 2 减小 200px。 整体减小空间的分配方式，是按照各自设置的 flex-shrink 比例分配的（2:1）。 对于 flex-grow 是同样的计算方式。当容器拉伸到 940px 时，整体增加了 300px，形状 1 增加 200px，而形状 2 增加 100px。 当涉及到 flex 属性时，比例是主要考虑的对象。 从上图中，可以看到宽度是如何根据设置的比率变化的，其中的 delta (∆) 表示和原始 flex-basis 相比的变化量。 结论最后重述：flex-basis 指的是一个元素在发生伸缩之前，沿着主轴方向的大小。flex-grow 指的是在元素拉伸时，和兄弟元素相比的拉伸比例。flex-shrink 指的是在元素收缩时，和兄弟元素相比的收缩比例。 我们还有几个 flexbox 属性要讲，请留意随后几周的文章。 非常感谢你们，非常感谢每个花时间阅读、评论和分享的读者，你们的鼓励是我不断前行的动力！","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"CSS","slug":"前端笔记/CSS","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://xiaoxiaoqdq.com/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://xiaoxiaoqdq.com/tags/flexbox/"}]},{"title":"通过动图形象地为你介绍Flexbox是如何工作的（一）","slug":"cs-flexbox-works-1","date":"2017-03-11T15:02:00.000Z","updated":"2017-03-11T15:37:58.083Z","comments":true,"path":"/blog/cs-flexbox-works-1/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/cs-flexbox-works-1/","excerpt":"","text":"flexbox 承诺将我们从万恶的纯 CSS 中拯救出来（如垂直对齐）。 flexbox 也正在实现它的这一目标，但是用户掌握这一新的模型也将会是个挑战。 因此在这里，我们将会用动图介绍 flexbox 是如何工作的，使得我们可以用它来做更好的布局。 flexbox 的潜在原则是使得布局更加灵活和直观。 为了完成这一目标，它允许容器自己来决定如何均匀地分布其中的元素——包括他们的尺寸和他们之间的间距。 这理论上来讲，听起来很美好。但是让我们来看一下实践中会发生什么。 在这篇文章中，我们会钻研5个通用 flexbox 原则。会探索它们都做了什么？你可以如何使用它们？以及它们的结果是什么样的？ 属性1：display: flex 在一个灰色背景的容器div里面，有四个颜色不同、尺寸不同的子div，此时每个div有默认的display: block，每一个的宽度也占满了一整行。 为了使用 flexbox，需要将你的容器放在 flex 容器中 ，见如下代码：123#container &#123; display: flex;&#125; 可以看到，发生了一点变化。你的四个div显示到了一行上，但也就仅此而已。可是你要知道，在这背后，你做了一件很有 power 的事情。你赋予了你的 div 一个叫做 flex上下文 的东西。 你现在可以把它应用在你的上下文中了，是不是比传统的 CSS 简单很多！ 属性2：flex-direction一个 flexbox 容器有两个坐标轴：主轴和交叉轴，直观的来看如下图： 默认情况下，元素都是从左到右地分布在主轴上。这就是为什么当你应用display: flex的时候，形状默认水平分布的原因。 flex-direction，可以使你的主轴旋转。1234#container &#123; display: flex; flex-direction: column;&#125; 这里有一个很重要的区别：flex-direction: column并不是把你的形状分布在交叉轴上。而是使主轴自身发生了旋转，从水平方向旋转到了垂直方向。 还有一些其他的flex-direction可选项，如：row-reverse和column-reverse。 属性3：justify-contentjustify-content控制的是你在主轴上如何对齐元素。 这里我们需要对主轴和交叉轴的区别有更深一点的理解。首先让我们回到flex-firection: row。12345#container &#123; display: flex; flex-direction: row; justify-content: flex-start;&#125; 使用 justify-content，你有五个选择： flex-start flex-end center space-between space-around space-around和space-between是最直观的。space-between使每个元素之间有相同的距离，但是不包含元素和容器之间的距离。 space-around让每个元素块的两侧有相同的空隙距离。这就意味着最外层的元素和容器之间的距离，是两个元素之间距离的一半（每个元素块的左右两侧都贡献了一个不重叠的等距离，因此是两倍的间隙）。 最后小结：记住justify-content是沿着主轴的，flex-direction是转换主轴的。这对你以后移动元素很关键。 属性4：align-items如果你已经消化了justify-content，那么align-items对你俩讲将是轻而易举的事了。 justify-content是沿着主轴的，而align-items是应用到交叉轴上的。 调整flex-direction，使得坐标轴看起来和上面的图一样。 接下来，我们一起看一下align-items命令。 flex-start flex-end center stretch baseline 前三个和justify-content没什么区别，后两个则有一些不同。 stretch你的元素将会被拉伸充满整个交叉轴。baseline则会使你的文字底部对齐。见图知意。 （注意：如果用align-items: stretch，你必须要将元素的height设置成auto，否则height属性将会覆盖stretch） 对于baseline要意识到，如果你把文字标签拿掉，那么将会用元素的底部对齐来替代原来的效果，如下图。 为了更好的展示主轴和交叉轴，我们结合justify-content和align-items来看一下两个flex-direction的核心不同。 用row，元素被分布在水平主轴上。用column，被分布在垂直主轴上。 在这两个 case 中，不论垂直还是水平方向，四个元素都是被居中的，但是这两种情况是绝对不能互相替换的。 属性5：align-selfalign-self允许你手动操作一个特定元素的对齐方式。 对于一个元素而言，它基本上是对align-items的覆盖。尽管align-self默认值设成了auto，但是它和align-items所有的属性都是一样的，这也使得这个元素继承了容器的align-items。1234567#container &#123; align-items: flex-start;&#125;.square#one &#123; align-self: center;&#125;// 只有这个形状会居中。 我们来看一下它设置的结果是什么样的。对前两个形状设置不同的align-self，其他元素设置为align-items: center和flex-direction: row。 结论尽管我们仅仅讲了 flexbox 的皮毛，但是这些命令应该也足够你应付很多基本布局了。 如果你还想看到更多的 GIF flexbox 教程，或者这篇教程对你有所帮助，请在下面给我点赞吧，或者给我留言。 感谢你的阅读！","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"CSS","slug":"前端笔记/CSS","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://xiaoxiaoqdq.com/tags/css/"},{"name":"flexbox","slug":"flexbox","permalink":"http://xiaoxiaoqdq.com/tags/flexbox/"}]},{"title":"无循环 JavaScript","slug":"js-without-loops","date":"2017-03-11T14:52:00.000Z","updated":"2017-03-11T15:41:54.813Z","comments":true,"path":"/blog/js-without-loops/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/js-without-loops/","excerpt":"","text":"之前有讨论过，缩进导致了代码复杂性的增加（以粗鲁的方式）。我们的目标是写出复杂度低的 JavaScript 代码。通过选择一种合适的抽象来解决这个问题，可是你怎么能知道选择哪一种抽象呢？很遗憾的是到目前为止，没有找到一个具体的例子能解释这一问题。这篇文章中我们讨论不用任何循环如何处理 JavaScript 数组，最终得出的效果是得到低复杂度的代码。 循环是一种很重要的控制结构，它很难被重用，也很难插入到其他操作之中。另外，它意味着随着每次迭代，代码也在不断的变化之中。——Luis Atencio 循环我们先前说过，像循环这样的控制结构引入了复杂性。但是至今也没能很好的解释这是如何发生的。那么我们首先来看一下在 JavaScript 中循环是如何起作用的。 在 JavaScript 中，至少有四、五种实现循环的方法。最基础的是 while 循环。首先，先创建一个示例函数和数组。1234567891011// oodlify :: String -&gt; Stringfunction oodlify(s) &#123; return s.replace(/[aeiou]/g, 'oodle');&#125;const input = [ 'John', 'Paul', 'George', 'Ringo',]; 现在有了一个数组，我们想要用 oodlify 函数处理每一个元素。如果用 while 循环，就类似于这样：123456789let i = 0;const len = input.length;let output = [];while (i &lt; len) &#123; let item = input[i]; let newItem = oodlify(item); output.push(newItem); i = i + 1;&#125; 注意看好每一步，首先用了一个计数器 i，把这个计数器初始化为 0，然后在每次循环中将其自增。每次必须要和 len 进行比较以保证它在那里停下来。这种方式太有共性了，所以 JavaScript 提供了一个更简单的实现方式： for 循环，写起来如下：1234567const len = input.length;let output = [];for (let i = 0; i &lt; len; i = i + 1) &#123; let item = input[i]; let newItem = oodlify(item); output.push(newItem);&#125; 这一结构非常有用，它把所有的计数器引用都放到了最上面，而 while 循环非常容易把自增的 i 给忘掉，进而引起无限循环。这确实是一个改进，但是重新思考一下这个问题。我们想要达到的目标是在数组的每个元素上运行 oodlify() 函数，并且将结果放到一个新的数组中，我们并不关心计数器的问题。 对一个数组中每个元素都进行操作的这种模式也是非常普遍的。因此，在 ES2015 中，有了一种新的循环结构，这种循环结构可以丢弃掉计数器： for...of 循环。每一次返回数组的下一个元素给你，代码如下：12345let output = [];for (let item of input) &#123; let newItem = oodlify(item); output.push(newItem);&#125; 这样就清晰很多，注意这里计数器和比较都不用了，甚至都不用将数组里的元素做一步额外的取出操作。for...of 帮我们做了里面的脏活累活。到此为止，我们用 for...of 来代替 for 循环，可以很大程度上降低复杂性。但是，我们还可以进一步优化它。 mappingfor...of 循环比 for 循环更清晰，但是依然需要一些设定性的代码。如不得不初始化一个 output 数组并且每次循环都要调用 push() 函数。但是如何解决这个问题，我们不妨先来扩展一下问题。 如果有两个数组需要调用 oodlify 函数会怎么样？12345678910111213141516const fellowship = [ 'frodo', 'sam', 'gandalf', 'aragorn', 'boromir', 'legolas', 'gimli',];const band = [ 'John', 'Paul', 'George', 'Ringo',]; 很直观的想法是为每个数组做循环：1234567891011let bandoodle = [];for (let item of band) &#123; let newItem = oodlify(item); bandoodle.push(newItem);&#125;let floodleship = [];for (let item of fellowship) &#123; let newItem = oodlify(item); floodleship.push(newItem);&#125; 这确实ok。有能正确执行的代码，就比没有好。但是，这是重复性的工作——不够“DRY”。我们来重构它以降低它的重复性，创建一个函数：1234567891011function oodlifyArray(input) &#123; let output = []; for (let item of input) &#123; let newItem = oodlify(item); output.push(newItem); &#125; return output;&#125;let bandoodle = oodlifyArray(band);let floodleship = oodlifyArray(fellowship); 这看起来好多了，可是如果我们想使用另外一个函数该怎么办？123function izzlify(s) &#123; return s.replace(/[aeiou]+/g, 'izzle');&#125; 上面的 oodlifyArray() 将不起作用了。可是如果再创建一个 izzlifyArray() 函数的话，那就又变成重复的问题了。先不管那么多，我们先将他们并排写出来：1234567891011121314151617function oodlifyArray(input) &#123; let output = []; for (let item of input) &#123; let newItem = oodlify(item); output.push(newItem); &#125; return output;&#125;function izzlifyArray(input) &#123; let output = []; for (let item of input) &#123; let newItem = izzlify(item); output.push(newItem); &#125; return output;&#125; 这两个函数惊人的相似。那么我们是不是可以把他们抽象成一个通用的模式呢？我们想要的是：给定一个函数和一个数组，通过这个函数，把数组中的每一个元素做操作后放到新的数组中。我们把这个模式叫做 map 。一个数组的 map 函数如下：1234567function map(f, a) &#123; let output = []; for (let item of a) &#123; output.push(f(item)); &#125; return output;&#125; 当然，这里并没有完全脱离循环。如果想要脱离循环的话，可以做一个递归的版本出来：1234function map(f, a) &#123; if (a.length === 0) &#123; return []; &#125; return [f(a[0])].concat(map(f, a.slice(1)));&#125; 递归解决方法非常优雅，仅仅用了两行代码，并且只有很少的缩进。但是通常我们并不倾向于使用递归，因为它在较老的浏览器中的性能非常差。实际上，我们并不是非得自己写 map（除非我们自己想写）。map 模式非常有共性，因此 JavaScript 提供了一个内置 map 方法。使用这个 map 方法，上面的代码变成了这样：1234let bandoodle = band.map(oodlify);let floodleship = fellowship.map(oodlify);let bandizzle = band.map(izzlify);let fellowshizzle = fellowship.map(izzlify); 可以注意到，缩进消失，循环消失。诚然，循环可能转移到了其他地方，可是这并不是我们所关心的。我们的代码现在变得简洁而富有表达张力。 为什么这个代码这么简单呢？这可能是个很傻的问题，不过也请思考一下。是因为短吗？不是，短并不代表不复杂。它很简单，是因为我们把问题分离了。有两个处理字符串的函数： oodlify 和 izzlify，这些函数并不需要知道关于数组或者循环的任何事情。同时，有另外一个函数： map ，它来处理数组，它不需要知道数组中元素是什么类型的，甚至你想对数组做什么也不用关心。它只需要执行我们所传递的函数就可以了。我们从对数组的处理中，把对字符串的处理分离出来，而不是把它们都混在一起。这就是为什么我们说上面的代码很简单。 reducing现在，map 已经得心应手了，但是这并没有覆盖到可能需要的每一种循环。只有当你想创建一个和输入数组同样长度的数组时才有用。但是如果你想要向数组中增加几个元素呢？或者想找一个列表中的最短字符串是哪个？其实有时我们对数组进行处理，最终只想得到一个值而已。 来看一个例子，现在有一个关于英雄的数组：1234567891011const heroes = [ &#123;name: 'Hulk', strength: 90000&#125;, &#123;name: 'Spider-Man', strength: 25000&#125;, &#123;name: 'Hawk Eye', strength: 136&#125;, &#123;name: 'Thor', strength: 100000&#125;, &#123;name: 'Black Widow', strength: 136&#125;, &#123;name: 'Vision', strength: 5000&#125;, &#123;name: 'Scarlet Witch', strength: 60&#125;, &#123;name: 'Mystique', strength: 120&#125;, &#123;name: 'Namora', strength: 75000&#125;,]; 我们想找最强壮的英雄。使用 for...of 循环，像这样：123456let strongest = &#123;strength: 0&#125;;for (hero of heroes) &#123; if (hero.strength &gt; strongest.strength) &#123; strongest = hero; &#125;&#125; 虽然这个代码可以正确运行，可是实在太烂了。看这个循环，每次都保存到目前为止最强的英雄。继续提需求，接下来我们想要所有英雄的组合强度值：1234let combinedStrength = 0;for (hero of heroes) &#123; combinedStrength += hero.strength;&#125; 在这两个例子中，都在循环开始之前初始化了一个变量。然后在每一次的循环中，处理一个数组元素，并且更新这个变量。为了使循环变得清晰，现在把数组中间的部分进行重构，重构到函数中。我们要重命名这些变量，以进一步突出相似性。123456789101112131415161718192021function greaterStrength(champion, contender) &#123; return (contender.strength &gt; champion.strength) ? contender : champion;&#125;function addStrength(tally, hero) &#123; return tally + hero.strength;&#125;const initialStrongest = &#123;strength: 0&#125;;let working = initialStrongest;for (hero of heroes) &#123; working = greaterStrength(working, hero);&#125;const strongest = working;const initialCombinedStrength = 0;working = initialCombinedStrength;for (hero of heroes) &#123; working = addStrength(working, hero);&#125;const combinedStrength = working; 写到这，两个循环变得非常相似了。它们两个之间唯一的区别是调用的函数和初始值不同。两个的功能都是对数组进行处理，最终得到一个值。所以，我们创建一个 reduce 函数来封装这个模式。1234567function reduce(f, initialVal, a) &#123; let working = initialVal; for (item of a) &#123; working = f(working, item); &#125; return working;&#125; reduce 模式在 JavaScript 中也是非常通用，因此 JavaScript 为数组提供了内置的方法，不需要自己来写。通过内置方法，代码就变成了：12const strongestHero = heroes.reduce(greaterStrength, &#123;strength: 0&#125;);const combinedStrength = heroes.reduce(addStrength, 0); ok，如果你认真思考，你会注意到上面的代码其实并没有短很多。不过也确实比自己手写的 reduce 代码少写了几行。但是我们的目标并不是使代码变短或者少写，而是降低复杂度。那么，我们降低了复杂度了吗？我会说是的。我们把处理个体的循环代码给分离了出去，现在的代码具有很少的耦合性，即很少的互相调用，复杂度得以下降。 reduce 方法乍一看可能觉得非常基础。关于 reduce 的例子大部分也都很简单，比如做加法。但是没有人说 reduce 方法只能返回基本类型，它可以是一个 object 类型，甚至可以是另一个数组。当我首次意识到这个问题的时候，自己也是豁然开朗。所以我们其实可以用 reduce 方法来写 map 或者 filter，这里我把这个任务留给你们自己来尝试。 filtering现在我们有了 map 处理数组中的每个元素，有了 reduce 处理数组维度，经过计算降到只得到一个值。但是如果想获取数组中的某些元素该怎么办？我们来进一步探索，现在增加一些属性到上面的英雄数组中：1234567891011const heroes = [ &#123;name: 'Hulk', strength: 90000, sex: 'm'&#125;, &#123;name: 'Spider-Man', strength: 25000, sex: 'm'&#125;, &#123;name: 'Hawk Eye', strength: 136, sex: 'm'&#125;, &#123;name: 'Thor', strength: 100000, sex: 'm'&#125;, &#123;name: 'Black Widow', strength: 136, sex: 'f'&#125;, &#123;name: 'Vision', strength: 5000, sex: 'm'&#125;, &#123;name: 'Scarlet Witch', strength: 60, sex: 'f'&#125;, &#123;name: 'Mystique', strength: 120, sex: 'f'&#125;, &#123;name: 'Namora', strength: 75000, sex: 'f'&#125;,]; ok，现在有两个问题，我们想要： 找到所有的女性英雄； 找到所有能量值大于500的英雄。 使用普通的 for...of 循环，会得到如下代码：12345678910111213let femaleHeroes = [];for (let hero of heroes) &#123; if (hero.sex === 'f') &#123; femaleHeroes.push(hero); &#125;&#125;let superhumans = [];for (let hero of heroes) &#123; if (hero.strength &gt;= 500) &#123; superhumans.push(hero); &#125;&#125; 上面代码运行起来没有问题，是不是看起来还不错？但是里面又出现了重复的情况。实际上，区别在于 if 的判断语句，那么能不能把 if 语句重构到一个函数中呢？123456789101112131415161718192021function isFemaleHero(hero) &#123; return (hero.sex === 'f');&#125;function isSuperhuman(hero) &#123; return (hero.strength &gt;= 500);&#125;let femaleHeroes = [];for (let hero of heroes) &#123; if (isFemaleHero(hero)) &#123; femaleHeroes.push(hero); &#125;&#125;let superhumans = [];for (let hero of heroes) &#123; if (isSuperhuman(hero)) &#123; superhumans.push(hero); &#125;&#125; 这种只返回 true 或者 false 的函数，我们一般把它称作 谓词。这里用了谓词来判断是否保存当前的英雄元素项。 上面代码的写法会看起来比较长。但是这样的重构很好地避免了之前的代码重复问题。可以进一步地抽象到一个函数中。1234567891011function filter(predicate, arr) &#123; let working = []; for (let item of arr) &#123; if (predicate(item)) &#123; working = working.concat(item); &#125; &#125;&#125;const femaleHeroes = filter(isFemaleHero, heroes);const superhumans = filter(isSuperhuman, heroes); 同 map 和 reduce 一样，JavaScript 提供了一个内置数组方法，没必要自己来实现（除非你自己想写）。用内置数组方法，上面的代码就变成了：12const femaleHeroes = heroes.filter(isFemaleHero);const superhumans = heroes.filter(isSuperhuman); 为什么这段代码比 for...of 循环好呢？回想一下整个过程，我们要解决一个“找到满足某一条件的所有英雄”。使用 filter 使得问题变得简单化了。我们需要做的就是通过写一个简单函数来告诉 filter 哪一个数组元素要保留。不需要考虑数组是什么样的，以及繁琐的中间变量。取而代之的是一个简单的谓词函数，仅此而已。 与其他的迭代器相比，使用 filter 是一个出小力办大事的过程。我们不需要通读循环代码来理解到底要过滤什么，要过滤的东西就在传递给他的那个函数里面。 findingfilter 已经信手拈来了吧。这时如果只想找一个英雄该怎么办？比如找 “Black Widow”。使用 filter 会写出如下代码：12345function isBlackWidow(hero) &#123; return (hero.name === 'Black Widow');&#125;const blackWidow = heroes.filter(isBlackWidow)[0]; 这段代码的问题是效率不够高。filter 会检查数组中的每一个元素，而我们知道这里面只有一个 “Black Widow”，当找到她的时候就可以停住，不用再看后面的元素了。那么，依旧利用谓词函数，我们写一个 find 函数来返回第一次匹配上的元素。123456789function find(predicate, arr) &#123; for (let item of arr) &#123; if (predicate(item)) &#123; return item; &#125; &#125;&#125;const blackWidow = find(isBlackWidow, heroes); 同样地，JavaScript 已经提供了这样的方法：1const blackWidow = heroes.find(isBlackWidow); 至此为止，find 再次体现了出小力办大事的原则。通过 find 方法，把问题简化为：你只要关注如何判断你要找的东西就可以了。不必关心迭代器到底怎么实现等细节问题。 总结这些迭代器函数的例子很好地诠释了为什么“抽象”非常有用。回想一下我们所讲的内置方法，每个例子中我们都做了三件事： 避免循环结构，使得代码变的简洁易读； 通过适当的方法名称来描述我们使用的模式，也就是：map，reduce，filter 和 find； 把问题从处理整个数组简化到处理每个元素。 这里要注意的是，我们把每个问题都打散，用一个或几个纯函数来解决。而真正令人兴奋的是仅仅通过 4 个模式（当然还有其他的模式，也建议大家去学习一下），在 JS 代码中你就可以消除几乎所有的循环了。这是因为 JS 中几乎每个循环都是用来处理数组，或者生成数组的。通过消除循环，降低了复杂性，也使得代码的可维护性更强。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/"},{"name":"Javascript","slug":"前端笔记/Javascript","permalink":"http://xiaoxiaoqdq.com/categories/前端笔记/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://xiaoxiaoqdq.com/tags/javascript/"}]},{"title":"Web前端开发工程师编程能力飞升之路","slug":"ms-beginner","date":"2017-03-10T05:32:00.000Z","updated":"2017-03-11T02:12:26.526Z","comments":true,"path":"/blog/ms-beginner/","link":"","permalink":"http://xiaoxiaoqdq.com//blog/ms-beginner/","excerpt":"","text":"最近在网上看到这篇“Web前端开发工程师编程能力飞升之路”的文章，受益颇深，故转载到博客中，勉励自己。作者把前端技术按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级，每个级别都提供了进阶之路，帮助在该等级迷茫的人们早日突破自己，更上一层楼。 背景如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧； 如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧； 如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧； web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！ 前言所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。 本文将web前端研发编程能力划分了八个等级，每个等级都列举出了对应的特征及破级提升之方法，希望每位在看本文的同学先准确定位自己的等级（不要以你目前能力的最高点，而是以你当前能力的中档与之等级作对比，以免多走弯路），参考突破之法破之。 所谓的级别，只是你面对需求时的一种态度：能够完成、能够完美地完成、能够超出预期地完成。以追求完美的态度加以扎实的编程功力，那就是你的编程水平。 切记心浮气燥，级别够了，那级别里的东西自然就懂了。悟了就是悟了，没悟也没关系，静下心来，投入时间而已。 一、入门能够解决一些问题的水平。有一定的基础（比如最常见的html标签及其属性、事件、方法；最常见的css属性；基础的javascript编程能力），能够完成一些简单的web前端研发需求。 举个例子：删除一字符串中指定的字符。 12345var str=\"www.baidu.com/?page\";str=str.replace('?page',\"\");alert(str);str=str.substring(0,str.indexof(\"/\"));alert(str); 首先不要苛责代码的对错严谨，毕竟每个程序员都有这样的一个过程；其次，这两段代码在这个实例里没有什么大过错，可能会有瑕疵，但能够解决问题（删除指定的字符），这就是这个级别的特征。 再举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 计算系统当前是星期几var str = \"\";var week = new date().getday();if (week == 0) &#123; str = \"今天是星期日\";&#125; else if (week == 1) &#123; str = \"今天是星期一\";&#125; else if (week == 2) &#123; str = \"今天是星期二\";&#125; else if (week == 3) &#123; str = \"今天是星期三\";&#125; else if (week == 4) &#123; str = \"今天是星期四\";&#125; else if (week == 5) &#123; str = \"今天是星期五\";&#125; else if (week == 6) &#123; str = \"今天是星期六\";&#125;// 或者更好一些var str1 = \"今天是星期\";var week = new date().getday();switch (week) &#123; case 0 : str1 += \"日\"; break; case 1 : str1 += \"一\"; break; case 2 : str1 += \"二\"; break; case 3 : str1 += \"三\"; break; case 4 : str1 += \"四\"; break; case 5 : str1 += \"五\"; break; case 6 : str1 += \"六\"; break;&#125;alert(str);alert(str1); 入门”阶段是每个程序员的必经之路，只要”入门”，你就上路了。所谓”师傅领进门，修行靠个人”，有了这个”入门”的基础，自己就可以摸索着前进了。 进阶之路将javascript、html、css之类的编码帮助手册里的每个方法/属性都通读几遍！只有将基础打好，以后的路才能走的顺畅。参考这些帮助文档，力争写出无瑕疵的代码。 这些编码文档建议不仅是在入门提高期看，在你以后每个阶段破阶的时候都应该看看，最基础的东西往往也是最给力的东西，有时能够给你带来意想不到的收获。 二、登堂能够正确地解决问题。不管你是通过搜索网络，或者通过改造某些成品代码（jquery/dojo/ext/yui）案例，只要能够无错地完成需求。 同样以上面的那段”字符串剪裁”代码为例： 123var str=\"www.baidu.com/?page\";str=str.replace(/?page/,\"\");alert(str); 仅仅解决问题对于”登堂”阶段来说已经不是问题，这个级别所给出方案不能是漏洞百出。以上面这段代码为例：replace方法的第一个参数虽然可以支持字符串，但最佳的类型是正则表达式； 1234var a = new array(\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\");var week = new date().getday();var str = \"今天是星期\"+ a[week];alert(str); 对比”入门级”的代码，不管是从代码量、代码效率、代码优美性、代码思路来说，”登堂”级的这个日期处理代码都要优秀很多。 进阶之路这个阶段虽然能够给出正确的解题方案，但是不一定是最优秀的方案。如何才能得到最优秀的方案呢？首先就是积累各种能够解决需求的方案，然后再验证每个方案，在这些方案中选择最好的一种。因此该阶段的进阶之路就是”行万里路，看万卷书”，积累各个需求的各个解决方案。 你可以扎身在专业论坛（蓝色理想、无忧、csdn）里，通读所有的faq及帖子；你可以打开搜索引擎，穷举所有的搜索结果。自己建立测试环境一一验 证这些代码：去揣摩每段代码的意图，去比较每段代码之间的差异。这两条路可以让你快速完成原始积累，当你再面对大多数需求时能够说这些问题我以前做过，那 你就水到渠成地晋阶了。 三、入室最强代码，知道所有能够解决需求的各种方案，能够选择使用最优秀的方案满足需求。这个级别基本上产品开发编程中的代码主力。给出的一招一式，招招都是绝招。 还以上面的那个例子为例，你能说出1、2、3之间的差别，以及适用于那种环境吗？ 1234567var str=\"www.baidu.com/?page\";// 1、字符串剪裁str.substring(0, str.indexof(\"?page\"));// 2、正则表达式str.replace(/?page/, \"\");// 3、字符串分拆、合并str.split(\"?page\").join(\"\"); 能够解决问题的方法会有很多，但是对于程序员来说应该选择最优秀的。上面这段代码从代码量来说”正则表达式”最优秀；从代码执行效率来说： “字符串剪裁”法最高（chrome中”正则表达式”效率最高），split法最次；从可扩展性上来说，”正则表达式”法最优。具体使用那种方案视具体的 需求环境而定。 “入室”阶段，程序员应该能够肯定的回答：对于这个需求而言，我的代码就是最优秀的代码。 再以”今天是星期几”为例，”登堂”级的代码你敢说是最优秀的代码了吗？ 12// 计算系统当前是星期几var str = \"今天是星期\" + \"日一二三四五六\".charat(new date().getday()); 对比”登堂”级的示例代码，上面这段代码给你什么感受？程序员追求的就是完美。”入室”级别追求的就是每一招每一式的完美无缺。 从web前端编程来说，通过2年左右的努力，很多人能够达到这个水平，但是，很大一部分人的编程能力也就止步于此。或限于产品的需求单一性，或限于需求开发的时间紧迫性，或限于人的惰性，能够完美地解决当前的需求就够了。 由于长期处于技术平台期，技术上得不到提高，通常这个级别的工程师会比较燥。技术上小有所成；或追求个人的突破；或追求产品差异性带来的新鲜感；或者只是想换个心情；因此很多此级别的工程师会经常换公司。 戒骄戒躁： 切勿以为自己能写一手漂亮的代码而自满； 切莫以为别人”尊称”你一声”大侠”你就以 “大侠”自居； 切莫以为自己积累了一些得意的代码就成了框架式开发。 细节决定成败，优秀的方案并不能保证最终的成功。还以”删除指定字符串”为例，原始字符串从格式上来看应该是了个url链接，在去除”pn=0″之 后，最末尾处留了一个尾巴”?”；如果原始字符串是”http://www.xxx.com/?pn=0&amp;a=1″，去除”pn=0″之后 ? 和 &amp; 两个符号紧贴一起，这更是明显的bug。 进阶之路此阶段进阶之路就是：切勿心浮气躁；你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。 再通读几遍html/css/javascript帮助文档。 我建议这个级别的工程师做一做webtreeview控件，要求总节点量一万左右操作流畅，你的晋升之路就在这个控件的编码过程中。 四、入微最强解决方案。你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及前端编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。 123456789101112131415161718192021var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0// 我将这个字符串里所可能想到的各种情况都列举出来var a = [ \"http://www.xxx.com/vmpn=?pn=0\"// pn= 可能出现在 ? 前 , \"http://www.xxx.com/vmpn=?pn=\"// url里允许pn 值为空 , \"http://www.xxx.com/vmpn=?pn=0&amp;a=1\"// url 里可有多个字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0\"// 可能排在最后 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1\"// 可能有多个 pn 字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=2\"// 可能在中间 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1&amp;b=1\" // 可能在中间成组 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=1&amp;pn=1\" // 可能零星分布];/* 需求的不言之秘：? 若出现在字符串最尾则要去之? &amp; 两个符号不可重叠*/var reg = /((\\?)(pn=[^&amp;]*&amp;)+(?!pn=))|(((\\?|&amp;)pn=[^&amp;]*)+$)|(&amp;pn=[^&amp;]*)/g;for (var i = 0; i &lt; a.length; i++) &#123; alert(a + \"\\n\" + a.replace(reg, \"$2\"));&#125; 这个阶段已经不再追求一招一式，对你来说不是使用什么创新绝招解决需求，而是给出成熟稳重的方案，从根上解决问题。针对某个当前需求你的代码可能不是最优，但是针对此类的需求你的代码却是最优秀的代码。 进阶之路很多web前端研发工程师在做了3-4年之后就会进入一个瓶颈期：产品开发需求是小菜一碟，没有新鲜的可以挑战的东西；代码开发中的稀奇的解题方法 都已经尝试过。没有了可挑战的难题，失去了探索的激情，也就没有了再上升的动力，好不容易走过”入室”级别的人又会有八九成止步于此。或转做技术领导人， 或转到其它的领域，或换公司。 这些人的上升之路在哪里呢？ 这个阶段单单依靠技巧和数量的累积已经没有什么效果了，突破之路在第5层《化蝶》里会详细说明，我建议你在这个阶段末尾着重关注编程理论：面向对象/过程、代码组织形式、编译、代码规范、其它的框架设计等等。 我建议这个级别的工程师做一做webeditor控件，不要求完整功能，但是该控件里的模块划分、代码组织、编程思想做到位，给出一个系统的解决方案。 五、化蝶破茧重生，这个层次关注的是编程语言本身，而不再关心产品需求。什么是茧？产品需求就是茧。当你一招胜万招，打遍天下需求之时，你如果还拘泥于需求开发，那就是你限于茧中而不自知。要么就在这个茧里默默地老去，要么就破开茧获得新生。 还是以那个”字符串剪裁”的老例子： 1234567891011121314151617181920212223242526272829/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author:meizz* @version: 2010/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/function escapereg(str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/function delurlquery(url, key) &#123; key = escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0delurlquery(str, \"pn\"); 这段代码相对于层次4《入微》有什么区别吗？从代码实现上来说没有太大的区别，但是从思路上来说却有着本质的区别：1、不再是就事论事，头疼医头，而是把一类问题抽象理论化，一招破万招；2、有封装的概念，不再是每次从零开始，而是站在半山腰开始爬。 在web前端研发队伍里也有很大一部分人《入室》层次时就自我感觉良好，直接跨跃到《化蝶》，积累自己的代码库，抽象化问题。但没有基础，缺少强大 的后劲，即使能够破茧也经受不了风吹雨打。一份不成熟的架构设计对团队开发带来的危害远大于它带来的好处，这种例子在业界屡见不鲜。不要拔苗助长，不要不 会走就想着跑，夯实基础，水到渠成地成长，厚积薄发，强力地破茧而出。 进阶之路你已经从原始积累，到厚积薄发，到破茧而出之后，你所关注的应该不再是一招一式、一个项目、一个模块，而应该是一种思路，一种理论。你可以做以下几 个步骤以突破到更高层次：再仔细看几遍html/css/javascript接口帮助文档；选择一门强语言（c++/c#/java等）观察理解这些语 言的组织结构，语言设计；看看原型链，链式语法编程，泛型，接口编程，dom遥控器等等；仔细阅读成熟的web前端开发框架的设计文档，看他们为什么要这 样设计。 六、大侠这里所说的大侠，不是大家互相吹捧的”大侠”，而是实至名归的高手。这个级别的人完全有能力写出不差于bindows/jquery/ext/yui/dojo的同等级别规模的前端开发框架。应用成熟的开发框架指导、解决问题。 123456789101112131415161718192021222324252627282930313233// 库文件 /mz/string/escapereg.js/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author:meizz* @version: 2010/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/mz.string.escapereg = function (str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125;// 库文件 /mz/url/delquery.js/// include mz.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/mz.url.delquery = function (url, key) &#123; key = mz.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例/// include mz.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0mz.url.delquery(str, \"pn\"); 自成体系，有基础，也有理论高度。知道为什么这样设计，也知道什么样的设计最好。比如这个例子可以有这样的封装： 123456789101112131415161718192021// 库文件 /mz/url/delquery.js/// include mz.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/string.prototype.delquery = function ( key) &#123; key = mz.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return this.replace(reg, \"\\x241\")&#125;// 应用实例/// include mz.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0str.delquery(\"pn\"); 而为什么不采用下面的那种封装呢？经过了《知微》和《化蝶》你就懂了。 进阶之路道法自然，从根上去寻找突破的契机。你可以研读html解析引擎设计与实现，js解析引擎设计与实现，其它语言的代码解析与编译实现等等。 或者出些书。低级别的人写的书要么是一大抄，空无一物；要么是害人。 七、宗师这个级别的人已然到了无招胜有招的境界。项目开发中的难题？没有难题！运行平台的差异？从根本上搞定！代码规范、开发模式，早已经被抛在身后。这个级别的人已经不再关注于某个前端开发框架，而是应对具体的环境给出最佳的理论指导。 这个级别的人所注意的应该是以最合理的系统架构引领着整个团队的进步，在什么样的场景下该用什么样的架构设计。3个、10个、50个、100个人的团队最应该用哪种模式？等你到了宗师级别，你再来回答吧。 进阶之路每一个宗师就是一个高山，就是一个领域里的神，但是你仅满足于在一群比你弱的群体展现你的强大吗？如果还你是止步原地，那总会有人乘着飞机、宇宙飞船从你的头领掠过，高处不胜寒！ 要突破这片领域，那就必须跳出这片领域。要想突破web前端研发的宗师级，那就跳出web前端吧，上面还有web开发。即使你是web前端的宗师， 但没有快速的数据响应，没有高速的网络架构，没有优美的系统支持，你又能如何？所以突破之路就是把目光投到整条web开发的链条中去。 八、飞升其实严格来说，飞升已经不是原领域的范围了。在web研发领域，对于这个层次的有一个很好听的称谓：架构师。当然那些”伪架构师”另当别论。 一法通，万法通。在其它的技术领域，也可以按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级；一样也可以按照我这里所写的每个级别的【进阶之路】来快速提升。 祝贺你再获辉煌！ 看完这篇文章，只能说自己的进步空间还很大，前端路漫漫，一起加油！ 原文链接未找到。再次感谢原文作者！","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"http://xiaoxiaoqdq.com/categories/面试宝典/"}],"tags":[{"name":"前端工程师","slug":"前端工程师","permalink":"http://xiaoxiaoqdq.com/tags/前端工程师/"}]}]}